{"version":3,"file":"content-content-search-handoff-ui-stories.edcb356e.iframe.bundle.js","mappings":";;;;;;;;;;;;;;;AAAA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACxFA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAGA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AAMA;AACA;AAMA;AAMA;AACA;AAMA;AACA;AAEA;AAMA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA","sources":["webpack:///../search/content/content-search-handoff-ui.stories.mjs","webpack:///../search/content/contentSearchHandoffUI.mjs"],"sourcesContent":["/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n// eslint-disable-next-line import/no-unresolved\nimport { html } from \"lit.all.mjs\";\nimport \"./contentSearchHandoffUI.mjs\";\n\nwindow.MozXULElement.insertFTLIfNeeded(\"branding/brand.ftl\");\nwindow.MozXULElement.insertFTLIfNeeded(\"browser/newtab/newtab.ftl\");\nwindow.MozXULElement.insertFTLIfNeeded(\"browser/aboutPrivateBrowsing.ftl\");\n\nexport default {\n  title: \"Domain-specific UI Widgets/Search/Handoff Search Bar\",\n  component: \"content-search-handoff-ui\",\n  argTypes: {},\n};\n\n/**\n * This little dance lets us mock out the response that the ContentSearch\n * parent/child actor pair returns when the ContentSearchHandoffUIController\n * requests engine information.\n */\naddEventListener(\"ContentSearchClient\", e => {\n  switch (e.detail.type) {\n    case \"GetEngine\": {\n      // We use the setTimeout(0) to queue up the response to occur on the next\n      // tick of the event loop.\n      setTimeout(() => {\n        e.target.dispatchEvent(\n          new CustomEvent(\"ContentSearchService\", {\n            detail: {\n              type: \"Engine\",\n              data: {\n                engine: {\n                  name: \"Google\",\n                  iconData: \"chrome://global/skin/icons/search-glass.svg\",\n                  isConfigEngine: true,\n                },\n                isPrivateEngine: false,\n              },\n            },\n          })\n        );\n      }, 0);\n      break;\n    }\n  }\n});\n\nconst Template = ({ fakeFocus, disabled }) => html`\n  <style>\n    .search-inner-wrapper {\n      display: flex;\n      min-height: 52px;\n      margin: 0 auto;\n      width: 720px;\n    }\n    content-search-handoff-ui {\n      --content-search-handoff-ui-fill: light-dark(#000000, #ffffff);\n      height: 50px;\n      width: 100%;\n    }\n  </style>\n\n  <div class=\"search-inner-wrapper\">\n    <content-search-handoff-ui\n      ?fakeFocus=${fakeFocus}\n      ?disabled=${disabled}\n    ></content-search-handoff-ui>\n  </div>\n`;\n\nexport const Focused = Template.bind({});\nFocused.args = {\n  fakeFocus: true,\n  disabled: false,\n};\n\nexport const Unfocused = Template.bind({});\nUnfocused.args = {\n  fakeFocus: false,\n  disabled: false,\n};\nexport const Disabled = Template.bind({});\nDisabled.args = {\n  fakeFocus: true,\n  disabled: true,\n};\n","import __chrome_styles_loader__contentSearchHandoffUIStyles from \"browser/components/search/content/contentSearchHandoffUI.css\";\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this file,\n * You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nimport { html } from \"chrome://global/content/vendor/lit.all.mjs\";\nimport { MozLitElement } from \"chrome://global/content/lit-utils.mjs\";\n\n/**\n * Handles handing off searches from an in-page search input field to the\n * browser's main URL bar. Communicates with the parent via the ContentSearch\n * actor, using custom events to talk to the child actor.\n */\nclass ContentSearchHandoffUIController {\n  #ui = null;\n  #shadowRoot = null;\n\n  /**\n   * Whether or not we are in private browsing mode.\n   */\n  #inPrivateBrowsing = false;\n\n  constructor(ui) {\n    this._isPrivateEngine = false;\n    this._engineIcon = null;\n    this.#ui = ui;\n    this.#shadowRoot = ui.shadowRoot;\n\n    window.addEventListener(\"ContentSearchService\", this);\n    this._sendMsg(\"GetEngine\");\n    this._sendMsg(\"GetHandoffSearchModePrefs\");\n  }\n\n  handleEvent(event) {\n    let methodName = \"_onMsg\" + event.detail.type;\n    if (methodName in this) {\n      this[methodName](event.detail.data);\n    }\n  }\n\n  get defaultEngine() {\n    return this._defaultEngine;\n  }\n\n  doSearchHandoff(text) {\n    this._sendMsg(\"SearchHandoff\", { text });\n  }\n\n  static privateBrowsingRegex = /^about:privatebrowsing([#?]|$)/i;\n  get _isAboutPrivateBrowsing() {\n    return ContentSearchHandoffUIController.privateBrowsingRegex.test(\n      document.location.href\n    );\n  }\n\n  _onMsgEngine({ inPrivateBrowsing, engine }) {\n    this.#inPrivateBrowsing = inPrivateBrowsing;\n    this._updateEngine(engine);\n  }\n\n  _onMsgCurrentEngine(engine) {\n    if (!this.#inPrivateBrowsing) {\n      this._updateEngine(engine);\n    }\n  }\n\n  _onMsgCurrentPrivateEngine(engine) {\n    if (this.#inPrivateBrowsing) {\n      this._updateEngine(engine);\n    }\n  }\n\n  _onMsgHandoffSearchModePrefs(pref) {\n    this._shouldHandOffToSearchMode = pref;\n    this._updatel10nIds();\n  }\n\n  _onMsgDisableSearch() {\n    this.#ui.disabled = true;\n  }\n\n  _onMsgShowSearch() {\n    this.#ui.disabled = false;\n    this.#ui.fakeFocus = false;\n  }\n\n  _updateEngine(engine) {\n    this._defaultEngine = engine;\n    if (this._engineIcon) {\n      URL.revokeObjectURL(this._engineIcon);\n    }\n\n    // We only show the engines icon for config engines, otherwise show\n    // a default. xref https://bugzilla.mozilla.org/show_bug.cgi?id=1449338#c19\n    if (!engine.isConfigEngine) {\n      this._engineIcon = \"chrome://global/skin/icons/search-glass.svg\";\n    } else if (engine.iconData) {\n      this._engineIcon = this._getFaviconURIFromIconData(engine.iconData);\n    } else {\n      this._engineIcon = \"chrome://global/skin/icons/defaultFavicon.svg\";\n    }\n\n    document.body.style.setProperty(\n      \"--newtab-search-icon\",\n      \"url(\" + this._engineIcon + \")\"\n    );\n    this._updatel10nIds();\n  }\n\n  _updatel10nIds() {\n    let engine = this._defaultEngine;\n    let fakeButton = this.#shadowRoot.querySelector(\".search-handoff-button\");\n    let fakeInput = this.#shadowRoot.querySelector(\".fake-textbox\");\n    if (!fakeButton || !fakeInput) {\n      return;\n    }\n    if (!engine || this._shouldHandOffToSearchMode) {\n      document.l10n.setAttributes(\n        fakeButton,\n        this._isAboutPrivateBrowsing\n          ? \"about-private-browsing-search-btn\"\n          : \"newtab-search-box-input\"\n      );\n      document.l10n.setAttributes(\n        fakeInput,\n        this._isAboutPrivateBrowsing\n          ? \"about-private-browsing-search-placeholder\"\n          : \"newtab-search-box-text\"\n      );\n    } else if (!engine.isConfigEngine) {\n      document.l10n.setAttributes(\n        fakeButton,\n        this._isAboutPrivateBrowsing\n          ? \"about-private-browsing-handoff-no-engine\"\n          : \"newtab-search-box-handoff-input-no-engine\"\n      );\n      document.l10n.setAttributes(\n        fakeInput,\n        this._isAboutPrivateBrowsing\n          ? \"about-private-browsing-handoff-text-no-engine\"\n          : \"newtab-search-box-handoff-text-no-engine\"\n      );\n    } else {\n      document.l10n.setAttributes(\n        fakeButton,\n        this._isAboutPrivateBrowsing\n          ? \"about-private-browsing-handoff\"\n          : \"newtab-search-box-handoff-input\",\n        {\n          engine: engine.name,\n        }\n      );\n      document.l10n.setAttributes(\n        fakeInput,\n        this._isAboutPrivateBrowsing\n          ? \"about-private-browsing-handoff-text\"\n          : \"newtab-search-box-handoff-text\",\n        {\n          engine: engine.name,\n        }\n      );\n    }\n  }\n\n  /**\n   * If the favicon is an iconData object, convert it into a Blob URI.\n   * Otherwise just return the plain URI.\n   *\n   * @param {string|iconData} data\n   *   The icon's URL or an iconData object containing the icon data.\n   * @returns {string}\n   *   A blob URL or the plain icon URI.\n   */\n  _getFaviconURIFromIconData(data) {\n    if (typeof data == \"string\") {\n      return data;\n    }\n\n    // If typeof(data) != \"string\", the iconData object is returned.\n    let blob = new Blob([data.icon], { type: data.mimeType });\n    return URL.createObjectURL(blob);\n  }\n\n  _sendMsg(type, data = null) {\n    dispatchEvent(\n      new CustomEvent(\"ContentSearchClient\", {\n        detail: {\n          type,\n          data,\n        },\n      })\n    );\n  }\n}\n\nwindow.ContentSearchHandoffUIController = ContentSearchHandoffUIController;\n\n/**\n * This custom element encapsulates the UI for the search handoff experience\n * for about:newtab and about:privatebrowsing. It is a temporary component\n * while we wait for the multi-context address bar (MCAB) to be available.\n */\nclass ContentSearchHandoffUI extends MozLitElement {\n  static queries = {\n    fakeCaret: \".fake-caret\",\n  };\n\n  static properties = {\n    fakeFocus: { type: Boolean, reflect: true },\n    disabled: { type: Boolean, reflect: true },\n  };\n\n  #controller = null;\n\n  #doSearchHandoff(text = \"\") {\n    this.fakeFocus = true;\n    this.#controller.doSearchHandoff(text);\n  }\n\n  #onSearchHandoffClick(event) {\n    // When search hand-off is enabled, we render a big button that is styled to\n    // look like a search textbox. If the button is clicked, we style\n    // the button as if it was a focused search box and show a fake cursor but\n    // really focus the awesomebar without the focus styles (\"hidden focus\").\n    event.preventDefault();\n    this.#doSearchHandoff();\n  }\n\n  #onSearchHandoffPaste(event) {\n    event.preventDefault();\n    this.#doSearchHandoff(event.clipboardData.getData(\"Text\"));\n  }\n\n  #onSearchHandoffDrop(event) {\n    event.preventDefault();\n    let text = event.dataTransfer.getData(\"text\");\n    if (text) {\n      this.#doSearchHandoff(text);\n    }\n  }\n\n  connectedCallback() {\n    super.connectedCallback();\n    if (!this.#controller) {\n      this.#controller = new window.ContentSearchHandoffUIController(this);\n    }\n  }\n\n  render() {\n    return html`\n      <link\n        rel=\"stylesheet\"\n        href=\"${__chrome_styles_loader__contentSearchHandoffUIStyles}\"\n      />\n      <button\n        class=\"search-handoff-button\"\n        @click=${this.#onSearchHandoffClick}\n        tabindex=\"-1\"\n      >\n        <div class=\"fake-textbox\"></div>\n        <input\n          type=\"search\"\n          class=\"fake-editable\"\n          tabindex=\"-1\"\n          aria-hidden=\"true\"\n          @drop=${this.#onSearchHandoffDrop}\n          @paste=${this.#onSearchHandoffPaste}\n        />\n        <div class=\"fake-caret\"></div>\n      </button>\n    `;\n  }\n}\n\ncustomElements.define(\"content-search-handoff-ui\", ContentSearchHandoffUI);\n"],"names":[],"sourceRoot":""}