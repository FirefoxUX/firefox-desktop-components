{"version":3,"file":"setting-control-setting-control-stories.665c02a9.iframe.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/IA;AACA;AACA;;AAEA;AAaA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAIA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack:///../preferences/widgets/setting-control/setting-control.stories.mjs","webpack:///../preferences/widgets/setting-control/setting-control.mjs"],"sourcesContent":["import __chrome_styles_loader__settingcontrolStyles from \"browser/components/preferences/widgets/setting-control/setting-control.css\";\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nimport { html } from \"chrome://global/content/vendor/lit.all.mjs\";\nimport \"chrome://browser/content/preferences/widgets/setting-control.mjs\";\n\nexport default {\n  title: \"Domain-specific UI Widgets/Settings/Setting Control\",\n  component: \"setting-control\",\n  parameters: {\n    status: \"in-development\",\n    handles: [\"click\", \"input\", \"change\"],\n    fluent: `\ncheckbox-example-input =\n  .label = Checkbox example of setting-control\n  .description = Could have a description like moz-checkbox.\nselect-example-input =\n  .label = Select example of setting-control\n  .description = Could have a description like moz-select.\nselect-option-0 =\n  .label = Option 0\nselect-option-1 =\n  .label = Option 1\nselect-option-2 =\n  .label = Option 2\nradio-example-input =\n  .label = Radio example of setting-control\n  .description = Could have a description like moz-radio-group.\nradio-option-0 =\n  .label = Option 0\nradio-option-1 =\n  .label = Option 1\n  .description = It's a full moz-radio\nradio-option-2 =\n  .label = Option 2\nextension-controlled-input =\n  .label = Setting controlled by extension\nextension-controlled-message = <strong>My Extension</strong> requires Controlled Setting.\n`,\n  },\n};\n\nconst Template = ({ config, setting }) => html`\n  <link\n    rel=\"stylesheet\"\n    href=\"${__chrome_styles_loader__settingcontrolStyles}\"\n  /><setting-control .config=${config} .setting=${setting}></setting-control>\n`;\n\nconst DEFAULT_SETTING = {\n  value: 1,\n  on() {},\n  off() {},\n  userChange() {},\n  getControlConfig: c => c,\n  controllingExtensionInfo: {},\n  visible: true,\n};\n\nexport const Checkbox = Template.bind({});\nCheckbox.args = {\n  config: {\n    id: \"checkbox-example\",\n    l10nId: \"checkbox-example-input\",\n  },\n  setting: DEFAULT_SETTING,\n};\n\nexport const Select = Template.bind({});\nSelect.args = {\n  config: {\n    id: \"select-example\",\n    l10nId: \"select-example-input\",\n    control: \"moz-select\",\n    supportPage: \"example-support\",\n    options: [\n      {\n        value: 0,\n        l10nId: \"select-option-0\",\n      },\n      {\n        value: 1,\n        l10nId: \"select-option-1\",\n      },\n      {\n        value: 2,\n        l10nId: \"select-option-2\",\n      },\n    ],\n  },\n  setting: DEFAULT_SETTING,\n};\n\nexport const Radio = Template.bind({});\nRadio.args = {\n  config: {\n    id: \"radio-example\",\n    l10nId: \"radio-example-input\",\n    control: \"moz-radio-group\",\n    supportPage: \"example-support\",\n    options: [\n      {\n        value: 0,\n        l10nId: \"radio-option-0\",\n      },\n      {\n        value: 1,\n        l10nId: \"radio-option-1\",\n        supportPage: \"support-page\",\n      },\n      {\n        value: 2,\n        l10nId: \"radio-option-2\",\n      },\n    ],\n  },\n  setting: DEFAULT_SETTING,\n};\n\nexport const ExtensionControlled = Template.bind({});\nExtensionControlled.args = {\n  config: {\n    id: \"extension-controlled-example\",\n    l10nId: \"extension-controlled-input\",\n    pref: \"privacy.userContext.enabled\",\n    controllingExtensionInfo: {\n      storeId: \"privacy.containers\",\n      /* Example of a Fluent string used for the message bar:\n       * extension-controlled-message = <strong>{ $name }</strong> requires Container Tabs.\n       * */\n      l10nId: \"extension-controlled-message\",\n    },\n  },\n  setting: {\n    ...DEFAULT_SETTING,\n    controllingExtensionInfo: {\n      id: \"extension-controlled-example\",\n      l10nId: \"extension-controlled-message\",\n      name: \"My Extension\",\n    },\n  },\n};\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nimport {\n  Directive,\n  createRef,\n  directive,\n  html,\n  ifDefined,\n  literal,\n  noChange,\n  nothing,\n  ref,\n  staticHtml,\n  unsafeStatic,\n} from \"chrome://global/content/vendor/lit.all.mjs\";\nimport { MozLitElement } from \"chrome://global/content/lit-utils.mjs\";\n\n/** @import MozCheckbox from \"../../../../../toolkit/content/widgets/moz-checkbox/moz-checkbox.mjs\"*/\n\n/**\n * A Lit directive that applies all properties of an object to a DOM element.\n *\n * This directive interprets keys in the provided props object as follows:\n * - Keys starting with `?` set or remove boolean attributes using `toggleAttribute`.\n * - Keys starting with `.` set properties directly on the element.\n * - Keys starting with `@` are currently not supported and will throw an error.\n * - All other keys are applied as regular attributes using `setAttribute`.\n *\n * It avoids reapplying values that have not changed, but does not currently\n * remove properties that were previously set and are no longer present in the new input.\n *\n * This directive is useful to \"spread\" an object of attributes/properties declaratively onto an\n * element in a Lit template.\n */\nclass SpreadDirective extends Directive {\n  /**\n   * A record of previously applied properties to avoid redundant updates.\n   * @type {Record<string, unknown>}\n   */\n  #prevProps = {};\n\n  /**\n   * Render nothing by default as all changes are made in update using DOM APIs\n   * on the element directly.\n   * @returns {typeof nothing}\n   */\n  render() {\n    return nothing;\n  }\n\n  /**\n   * Apply props to the element using DOM APIs, updating only changed values.\n   * @param {AttributePart} part - The part of the template this directive is bound to.\n   * @param {[Record<string, unknown>]} propsArray - An array with a single object containing props to apply.\n   * @returns {typeof noChange} - Indicates to Lit that no re-render is needed.\n   */\n  update(part, [props]) {\n    // TODO: This doesn't clear any values that were set in previous calls if\n    // they are no longer present.\n    // It isn't entirely clear to me (mstriemer) what we should do if a prop is\n    // removed, or if the prop has changed from say ?foo to foo. By not\n    // implementing the auto-clearing hopefully the consumer will do something\n    // that fits their use case.\n\n    /** @type {HTMLElement} */\n    let el = part.element;\n\n    for (let [key, value] of Object.entries(props)) {\n      // Skip if the value hasn't changed since the last update.\n      if (value === this.#prevProps[key]) {\n        continue;\n      }\n\n      // Update the element based on the property key matching Lit's templates:\n      //   ?key -> el.toggleAttribute(key, value)\n      //   .key -> el.key = value\n      //   key -> el.setAttribute(key, value)\n      if (key.startsWith(\"?\")) {\n        el.toggleAttribute(key.slice(1), Boolean(value));\n      } else if (key.startsWith(\".\")) {\n        el[key.slice(1)] = value;\n      } else if (key.startsWith(\"@\")) {\n        throw new Error(\n          `Event listeners are not yet supported with spread (${key})`\n        );\n      } else {\n        el.setAttribute(key, String(value));\n      }\n    }\n\n    // Save current props for comparison in the next update.\n    this.#prevProps = props;\n\n    return noChange;\n  }\n}\n\nconst spread = directive(SpreadDirective);\n\n/**\n * @type Map<string, HTMLElement>\n */\nconst controlInstances = new Map();\nfunction getControlInstance(control = \"moz-checkbox\") {\n  if (!controlInstances.has(control)) {\n    controlInstances.set(control, document.createElement(control));\n  }\n  return controlInstances.get(control);\n}\n\n/**\n * Mapping of parent control tag names to the literal tag name for their\n * expected children. eg. \"moz-radio-group\"->literal`moz-radio`.\n * @type Map<string, literal>\n */\nconst KNOWN_OPTIONS = new Map([\n  [\"moz-radio-group\", literal`moz-radio`],\n  [\"moz-select\", literal`moz-option`],\n  [\"moz-visual-picker\", literal`moz-visual-picker-item`],\n]);\n\n/**\n * Mapping of parent control tag names to the expected slot for their children.\n * If there's no entry here for a control then it's expected that its children\n * should go in the default slot.\n * @type Map<string, string>\n */\nconst ITEM_SLOT_BY_PARENT = new Map([\n  [\"moz-checkbox\", \"nested\"],\n  [\"moz-input-text\", \"nested\"],\n  [\"moz-input-search\", \"nested\"],\n  [\"moz-input-folder\", \"nested\"],\n  [\"moz-input-password\", \"nested\"],\n  [\"moz-radio-group\", \"nested\"],\n  // NOTE: moz-select does not support the nested slot.\n  [\"moz-toggle\", \"nested\"],\n]);\n\nexport class SettingControl extends MozLitElement {\n  /**\n   * @type {Setting | undefined}\n   */\n  #lastSetting;\n\n  static properties = {\n    setting: { type: Object },\n    config: { type: Object },\n    value: {},\n    parentDisabled: { type: Boolean },\n  };\n\n  constructor() {\n    super();\n    this.controlRef = createRef();\n\n    /**\n     * @type {Preferences['getSetting'] | undefined}\n     */\n    this.getSetting = undefined;\n\n    /**\n     * @type {Setting | undefined}\n     */\n    this.setting = undefined;\n\n    /**\n     * @type {PreferencesSettingsConfig | undefined}\n     */\n    this.config = undefined;\n\n    /**\n     * @type {boolean | undefined}\n     */\n    this.parentDisabled = undefined;\n  }\n\n  createRenderRoot() {\n    return this;\n  }\n\n  focus() {\n    this.controlRef.value.focus();\n  }\n\n  get controlEl() {\n    return this.controlRef.value;\n  }\n\n  async getUpdateComplete() {\n    let result = await super.getUpdateComplete();\n    await this.controlEl.updateComplete;\n    return result;\n  }\n\n  onSettingChange = () => {\n    this.setValue();\n    this.requestUpdate();\n  };\n\n  /**\n   * @type {MozLitElement['willUpdate']}\n   */\n  willUpdate(changedProperties) {\n    if (changedProperties.has(\"setting\")) {\n      if (this.#lastSetting) {\n        this.#lastSetting.off(\"change\", this.onSettingChange);\n      }\n      this.#lastSetting = this.setting;\n      this.setValue();\n      this.setting.on(\"change\", this.onSettingChange);\n    }\n    this.hidden = !this.setting.visible;\n  }\n\n  updated() {\n    this.controlRef?.value?.requestUpdate();\n  }\n\n  /**\n   * The default properties that controls and options accept.\n   * Note: for the disabled property, a setting can either be locked,\n   * or controlled by an extension but not both.\n   *\n   * @param {PreferencesSettingsConfig} config\n   * @returns {Record<string, any>}\n   */\n  getCommonPropertyMapping(config) {\n    return {\n      id: config.id,\n      \"data-l10n-id\": config.l10nId,\n      \"data-l10n-args\": config.l10nArgs\n        ? JSON.stringify(config.l10nArgs)\n        : undefined,\n      \".iconSrc\": config.iconSrc,\n      \".supportPage\": config.supportPage,\n      \".setting\": this.setting,\n      \".control\": this,\n      \"data-subcategory\": config.subcategory,\n      ...config.controlAttrs,\n    };\n  }\n\n  /**\n   * The default properties for an option.\n   */\n  getOptionPropertyMapping(config) {\n    const props = this.getCommonPropertyMapping(config);\n    props[\".value\"] = config.value;\n    return props;\n  }\n\n  /**\n   * The default properties for this control.\n   */\n  getControlPropertyMapping(config) {\n    const props = this.getCommonPropertyMapping(config);\n    props[\".parentDisabled\"] = this.parentDisabled;\n    props[\".control\"] = this;\n    props[\"?disabled\"] =\n      this.setting.disabled ||\n      this.setting.locked ||\n      this.isControlledByExtension();\n\n    // Set the value based on the control's API.\n    let instance = getControlInstance(config.control);\n    if (\"checked\" in instance) {\n      props[\".checked\"] = this.value;\n    } else if (\"pressed\" in instance) {\n      props[\".pressed\"] = this.value;\n    } else if (\"value\" in instance) {\n      props[\".value\"] = this.value;\n    }\n\n    return props;\n  }\n\n  getValue() {\n    return this.setting.value;\n  }\n\n  setValue = () => {\n    this.value = this.setting.value;\n  };\n\n  /**\n   * @param {MozCheckbox | HTMLInputElement} el\n   * @returns {boolean | string | undefined}\n   */\n  controlValue(el) {\n    if (el.constructor.activatedProperty && el.localName != \"moz-radio\") {\n      return el[el.constructor.activatedProperty];\n    } else if (el.localName == \"moz-input-folder\") {\n      return el.folder;\n    }\n    return el.value;\n  }\n\n  // Called by our parent when our input changed.\n  onChange(el) {\n    this.setting.userChange(this.controlValue(el));\n  }\n\n  onClick(event) {\n    this.setting.userClick(event);\n  }\n\n  async disableExtension() {\n    await this.setting.disableControllingExtension();\n  }\n\n  isControlledByExtension() {\n    return (\n      this.setting.controllingExtensionInfo?.id &&\n      this.setting.controllingExtensionInfo?.name\n    );\n  }\n\n  get extensionName() {\n    return this.setting.controllingExtensionInfo.name;\n  }\n\n  get extensionMessageId() {\n    return this.setting.controllingExtensionInfo.l10nId;\n  }\n\n  render() {\n    // Allow the Setting to override the static config if necessary.\n    this.config = this.setting.getControlConfig(this.config);\n    let { config } = this;\n    let control = config.control || \"moz-checkbox\";\n    let getItemArgs = items =>\n      items?.map(i => ({\n        config: i,\n        setting: this.getSetting(i.id),\n      })) || [];\n\n    // Prepare nested item config and settings.\n    let itemArgs = getItemArgs(config.items);\n    let itemTemplate = opts =>\n      html`<setting-control\n        .config=${opts.config}\n        .setting=${opts.setting}\n        .getSetting=${this.getSetting}\n        slot=${ifDefined(ITEM_SLOT_BY_PARENT.get(control))}\n      ></setting-control>`;\n    let nestedSettings = itemArgs.map(itemTemplate);\n\n    // Prepare any children that this element may need.\n    let controlChildren = nothing;\n    if (config.options) {\n      controlChildren = config.options.map(opt => {\n        let optionTag = opt.control\n          ? unsafeStatic(opt.control)\n          : KNOWN_OPTIONS.get(control);\n        return staticHtml`<${optionTag}\n          ${spread(this.getOptionPropertyMapping(opt))}\n        >${opt.items ? getItemArgs(opt.items).map(itemTemplate) : \"\"}</${optionTag}>`;\n      });\n    }\n\n    // Get the properties for this element: id, fluent, disabled, etc.\n    // These will be applied to the control using the spread directive.\n    let controlProps = this.getControlPropertyMapping(config);\n\n    let tag = unsafeStatic(control);\n    let messageBar;\n    if (this.isControlledByExtension()) {\n      let args = { name: this.extensionName };\n      messageBar = html`<moz-message-bar\n        class=\"extension-controlled-message-bar\"\n        .messageL10nId=${this.extensionMessageId}\n        .messageL10nArgs=${args}\n      >\n        <moz-button\n          slot=\"actions\"\n          @click=${this.disableExtension}\n          data-l10n-id=\"disable-extension\"\n        ></moz-button>\n      </moz-message-bar>`;\n    }\n    return staticHtml`\n    ${messageBar}\n    <${tag}\n      ${spread(controlProps)}\n      ${ref(this.controlRef)}\n    >${controlChildren}${nestedSettings}</${tag}>`;\n  }\n}\ncustomElements.define(\"setting-control\", SettingControl);\n"],"names":[],"sourceRoot":""}