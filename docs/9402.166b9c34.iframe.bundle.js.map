{"version":3,"file":"9402.166b9c34.iframe.bundle.js","mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACA;;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzKA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack:///../../../toolkit/content/widgets/moz-input-folder/moz-input-folder.mjs","webpack:///../../../toolkit/content/widgets/moz-input-text/moz-input-text.mjs"],"sourcesContent":["import __chrome_styles_loader__mozinputfolderStyles from \"toolkit/content/widgets/moz-input-folder/moz-input-folder.css\";\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nimport { html, classMap, styleMap } from \"../vendor/lit.all.mjs\";\nimport MozInputText from \"chrome://global/content/elements/moz-input-text.mjs\";\n\nwindow.MozXULElement?.insertFTLIfNeeded(\"toolkit/global/mozInputFolder.ftl\");\n\n/**\n * An input folder custom element.\n *\n * @tagname moz-input-folder\n *\n * @property {string} label - The text of the label element\n * @property {string} name - The name of the input control\n * @property {string} value - The path to the selected folder\n * @property {boolean} disabled - The disabled state of the component\n * @property {string} iconSrc - The src for an optional icon in the label\n * @property {string} description - The text for the description element that helps describe the input control\n * @property {string} supportPage - Name of the SUMO support page to link to.\n * @property {string} placeholder - Text to display when the input has no value.\n * @property {string} displayValue - The value of the input control if it's different from the component value.\n * @property {string} dialogTitle - Text to display as a file picker dialog title.\n * @property {object} folder - The file object that represents the selected folder.\n */\n\nexport default class MozInputFolder extends MozInputText {\n  #folder;\n\n  static properties = {\n    displayValue: { type: String },\n    dialogTitle: { type: String, fluent: true },\n    _inputIconSrc: { type: String, state: true },\n  };\n\n  static queries = {\n    chooseFolderButtonEl: \"#choose-folder-button\",\n  };\n\n  constructor() {\n    super();\n    this.readonly = true;\n    this.displayValue = \"\";\n    this.dialogTitle = \"\";\n    this._inputIconSrc = \"\";\n    this.#folder = null;\n  }\n\n  willUpdate(changedProperties) {\n    super.willUpdate(changedProperties);\n\n    if (changedProperties.has(\"readonly\")) {\n      this.readonly = true;\n    }\n    if (changedProperties.has(\"value\")) {\n      if (this.value == \"\") {\n        this.#folder = null;\n        this._inputIconSrc = \"\";\n      } else if (!this.#folder || this.value != this.#folder.path) {\n        let currentValue = this.value;\n        this.getFolderFromPath(this.value).then(folder => {\n          if (this.value === currentValue) {\n            this.#folder = folder;\n            this._inputIconSrc = this.getInputIconSrc(this.#folder);\n          }\n        });\n      } else {\n        this._inputIconSrc = this.getInputIconSrc(this.#folder);\n      }\n    }\n  }\n\n  get folder() {\n    return this.#folder;\n  }\n\n  async getFolderFromPath(path) {\n    let folder = null;\n    try {\n      folder = await IOUtils.getDirectory(path);\n    } catch (e) {\n      //Not a valid path\n      console.error(\n        \"The error occurred while attempting to get directory from the moz-input-folder value\"\n      );\n    }\n\n    return folder;\n  }\n\n  getInputIconSrc(folder) {\n    if (!folder) {\n      return \"\";\n    }\n\n    let fph = Services.io\n      .getProtocolHandler(\"file\")\n      .QueryInterface(Ci.nsIFileProtocolHandler);\n    let iconUrlSpec = fph.getURLSpecFromDir(folder);\n    let inputIconSrc = \"moz-icon://\" + iconUrlSpec + \"?size=16\";\n    return inputIconSrc;\n  }\n\n  async openFolderPicker() {\n    let folderPicker = Cc[\"@mozilla.org/filepicker;1\"].createInstance(\n      Ci.nsIFilePicker\n    );\n    let mode = Ci.nsIFilePicker.modeGetFolder;\n    folderPicker.init(window.browsingContext, this.dialogTitle, mode);\n    folderPicker.appendFilters(Ci.nsIFilePicker.filterAll);\n\n    if (this.#folder) {\n      folderPicker.displayDirectory = this.#folder;\n    }\n\n    let result = await new Promise(resolve => folderPicker.open(resolve));\n    if (\n      result != Ci.nsIFilePicker.returnOK ||\n      this.value == folderPicker.file.path\n    ) {\n      if (Cu.isInAutomation) {\n        // Dispatch a test-only event so we can tell that the dialog is closing.\n        this.dispatchEvent(new CustomEvent(\"moz-input-folder-picker-close\"));\n      }\n\n      return;\n    }\n\n    this.#folder = folderPicker.file;\n    this.value = this.#folder.path;\n\n    this.dispatchEvent(new Event(\"input\", { bubbles: true }));\n    this.dispatchEvent(new Event(\"change\", { bubbles: true }));\n  }\n\n  inputStylesTemplate() {\n    return html`<link\n      rel=\"stylesheet\"\n      href=\"${__chrome_styles_loader__mozinputfolderStyles}\"\n    />`;\n  }\n\n  inputTemplate() {\n    let inputValue = this.displayValue || this.value;\n    let classes, styles;\n    if (this._inputIconSrc) {\n      classes = classMap({\n        \"with-icon\": true,\n      });\n      styles = styleMap({\n        \"--input-background-icon\": `url(${this._inputIconSrc})`,\n      });\n    }\n\n    return html`\n      <div class=\"container\">\n        ${super.inputTemplate({ classes, styles, inputValue })}\n        <moz-button\n          id=\"choose-folder-button\"\n          data-l10n-id=\"choose-folder-button\"\n          ?disabled=${this.disabled || this.parentDisabled}\n          @click=${this.openFolderPicker}\n        ></moz-button>\n      </div>\n    `;\n  }\n}\ncustomElements.define(\"moz-input-folder\", MozInputFolder);\n","import __chrome_styles_loader__mozinputtextStyles from \"toolkit/content/widgets/moz-input-text/moz-input-text.css\";\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nimport { html, ifDefined } from \"../vendor/lit.all.mjs\";\nimport { MozBaseInputElement } from \"../lit-utils.mjs\";\n\n/**\n * A text input custom element.\n *\n * @tagname moz-input-text\n * @property {string} label - The text of the label element\n * @property {string} name - The name of the input control\n * @property {string} value - The value of the input control\n * @property {boolean} disabled - The disabled state of the input control\n * @property {boolean} readonly - The readonly state of the input control\n * @property {string} iconSrc - The src for an optional icon\n * @property {string} description - The text for the description element that helps describe the input control\n * @property {string} supportPage - Name of the SUMO support page to link to.\n * @property {string} placeholder - Text to display when the input has no value.\n */\nexport default class MozInputText extends MozBaseInputElement {\n  static properties = {\n    placeholder: { type: String, fluent: true },\n    readonly: { type: Boolean, mapped: true },\n  };\n  static inputLayout = \"block\";\n\n  constructor() {\n    super();\n    this.value = \"\";\n    this.readonly = false;\n  }\n\n  inputStylesTemplate() {\n    return html`<link\n      rel=\"stylesheet\"\n      href=\"${__chrome_styles_loader__mozinputtextStyles}\"\n    />`;\n  }\n\n  handleInput(e) {\n    this.value = e.target.value;\n  }\n\n  inputTemplate(options = {}) {\n    let { type = \"text\", classes, styles, inputValue } = options;\n\n    return html`\n      <input\n        id=\"input\"\n        type=${type}\n        class=${ifDefined(classes)}\n        style=${ifDefined(styles)}\n        name=${this.name}\n        value=${inputValue || this.value}\n        ?disabled=${this.disabled || this.parentDisabled}\n        ?readonly=${this.readonly}\n        accesskey=${ifDefined(this.accessKey)}\n        placeholder=${ifDefined(this.placeholder)}\n        aria-describedby=\"description\"\n        @input=${this.handleInput}\n        @change=${this.redispatchEvent}\n      />\n    `;\n  }\n}\ncustomElements.define(\"moz-input-text\", MozInputText);\n"],"names":[],"sourceRoot":""}