{"version":3,"file":"moz-reorderable-list-moz-reorderable-list-stories.bcf741f4.iframe.bundle.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAQA;AACA;;AAEA;AACA;AACA;AACA;AAKA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;ACtdA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAIA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA","sources":["webpack:///../../../toolkit/content/widgets/moz-reorderable-list/moz-reorderable-list.mjs","webpack:///../../../toolkit/content/widgets/moz-reorderable-list/moz-reorderable-list.stories.mjs"],"sourcesContent":["import __chrome_styles_loader__mozreorderablelistStyles from \"toolkit/content/widgets/moz-reorderable-list/moz-reorderable-list.css\";\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nimport { html } from \"../vendor/lit.all.mjs\";\nimport { MozLitElement } from \"../lit-utils.mjs\";\n\nconst REORDER_EVENT = \"reorder\";\nconst DRAGSTART_EVENT = \"dragstarted\";\nconst DRAGEND_EVENT = \"dragended\";\nconst DRAG_DATA_TYPE_PREFIX = \"text/reorderable-item/\";\nconst REORDER_PROP = \"__mozReorderableIndex\";\n\n/**\n * A wrapper element that allows its children to be reordered by dragging and\n * dropping. The element emits the custom `reorder` event when an item is\n * dropped in a new position, which you can use to perform the actual\n * reordering.\n *\n * The detail object of the `reorder` event contains the following properties:\n *\n * - `draggedElement`: The element that was dragged.\n * - `targetElement`: The element over which the dragged element was dropped.\n * - `position`: The position of the drop relative to the target element. -1\n *   means before, 0 means after.\n *\n * Which children are reorderable is determined by the `itemSelector` property.\n *\n * Things to keep in mind when using this element:\n *\n * - Preserve the focus when reordering items.\n * - Check that the reordering shortcuts are not in conflict with other\n *   shortcuts.\n * - Make sure that reordering is picked up by screen readers. Usually DOM\n *   updates cause the reordered element to be read out again, which is\n *   sufficient.\n *\n * @tagname moz-reorderable-list\n * @property {string} itemSelector\n *   Selector for elements that should be reorderable.\n * @property {string} dragSelector\n *   Selector used when only part of the reorderable element should be draggable,\n *   e.g. we use a button or an icon as a \"handle\" to drag the element.\n * @fires reorder - Fired when an item is dropped in a new position.\n * @fires dragstarted - Fired when an item is dragged.\n * @fires dragended - Fired when an item is dropped.\n */\nexport default class MozReorderableList extends MozLitElement {\n  static queries = {\n    slotEl: \"slot\",\n    indicatorEl: \".indicator\",\n  };\n\n  static properties = {\n    itemSelector: { type: String },\n    dragSelector: { type: String },\n  };\n\n  #draggedElement = null;\n  #dropTargetInfo = null;\n  #mutationObserver = null;\n  #items = [];\n\n  isXULElement(element) {\n    return window.XULElement?.isInstance?.(element);\n  }\n\n  getBounds(element) {\n    return (\n      window.windowUtils?.getBoundsWithoutFlushing?.(element) ||\n      element.getBoundingClientRect()\n    );\n  }\n\n  constructor() {\n    super();\n    this.itemSelector = \"li\";\n    this.addEventListener(\"dragstart\", this.onDragStart);\n    this.addEventListener(\"dragover\", this.onDragOver);\n    this.addEventListener(\"dragleave\", this.onDragLeave);\n    this.addEventListener(\"dragend\", this.onDragEnd);\n    this.addEventListener(\"drop\", this.onDrop);\n    this.#mutationObserver = new MutationObserver((...args) =>\n      this.onMutation(...args)\n    );\n  }\n\n  firstUpdated() {\n    super.firstUpdated();\n    this.getItems();\n  }\n\n  connectedCallback() {\n    super.connectedCallback();\n    this.#mutationObserver.observe(this, {\n      childList: true,\n      subtree: true,\n    });\n  }\n\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    this.#mutationObserver.disconnect();\n  }\n\n  onMutation(mutationList) {\n    let needsUpdate = false;\n\n    for (const mutation of mutationList) {\n      if (mutation.addedNodes.length || mutation.removedNodes.length) {\n        needsUpdate = true;\n        break;\n      }\n    }\n\n    if (needsUpdate) {\n      // Defer re-querying for items until the next paint to ensure any\n      // asynchronously rendered (i.e. Lit-based) elements are in the DOM.\n      requestAnimationFrame(() => {\n        this.getItems();\n      });\n    }\n  }\n\n  /**\n   * Add the draggable attribute non-XUL elements.\n   */\n  addDraggableAttribute(items) {\n    let draggableItems = items;\n    if (this.dragSelector) {\n      draggableItems = this.getAssignedElementsBySelector(\n        this.dragSelector,\n        items\n      );\n    }\n    for (const item of draggableItems) {\n      // Unlike XUL elements, HTML elements are not draggable by default.\n      // So we need to set the draggable attribute on all items that match the selector.\n      if (!this.isXULElement(item)) {\n        item.draggable = true;\n      }\n    }\n  }\n\n  onDragStart(event) {\n    let draggedElement = this.getTargetItemFromEvent(event);\n    if (!draggedElement) {\n      return;\n    }\n\n    const dragIndex = this.getItemIndex(draggedElement);\n    if (dragIndex === -1) {\n      return;\n    }\n\n    event.stopPropagation();\n\n    this.emitEvent(DRAGSTART_EVENT, {\n      draggedElement,\n    });\n\n    // In privileged documents, use a canvas element combined with the\n    // drawWindow API to create a more accurate drag image. This is especially\n    // useful when dragging composite custom elements.\n    if (window.document.nodePrincipal?.isSystemPrincipal) {\n      let rect = this.getBounds(draggedElement);\n      let scale = window.devicePixelRatio || 1;\n\n      let canvas = document.createElement(\"canvas\");\n      canvas.width = rect.width * scale;\n      canvas.height = rect.height * scale;\n\n      let context = canvas.getContext(\"2d\");\n      context.scale(scale, scale);\n      context.drawWindow(\n        window,\n        rect.left,\n        rect.top,\n        rect.width,\n        rect.height,\n        \"rgb(255,255,255)\"\n      );\n      event.dataTransfer.setDragImage(canvas, 0, 0);\n    }\n\n    // XUL elements need dataTransfer values to be set for drag and drop to work.\n    if (this.isXULElement(draggedElement)) {\n      let documentId = draggedElement.ownerDocument.documentElement.id;\n      event.dataTransfer.mozSetDataAt(\n        `${DRAG_DATA_TYPE_PREFIX}${documentId}`,\n        draggedElement.id,\n        0\n      );\n      event.dataTransfer.addElement(draggedElement);\n      event.dataTransfer.effectAllowed = \"move\";\n    }\n\n    this.#draggedElement = draggedElement;\n  }\n\n  onDragOver(event) {\n    this.#dropTargetInfo = this.getDropTargetInfo(event);\n    if (!this.#dropTargetInfo) {\n      this.indicatorEl.hidden = true;\n      return;\n    }\n    event.preventDefault();\n    event.stopPropagation();\n    const { targetIndex, position } = this.#dropTargetInfo;\n    const items = this.#items;\n    const item = items[targetIndex];\n\n    if (!item) {\n      this.indicatorEl.hidden = true;\n      return;\n    }\n\n    const containerRect = this.getBounds(this);\n    const itemRect = this.getBounds(item);\n\n    this.indicatorEl.hidden = false;\n    if (position < 0) {\n      this.indicatorEl.style.top = `${itemRect.top - containerRect.top}px`;\n    } else {\n      this.indicatorEl.style.top = `${itemRect.bottom - containerRect.top}px`;\n    }\n  }\n\n  onDragLeave(event) {\n    let path = event.composedPath();\n    let draggedEl = path.find(el => el.matches?.(this.itemSelector));\n    if (!draggedEl) {\n      return;\n    }\n    let target = event.relatedTarget;\n    while (target && target !== this) {\n      target = target.parentNode;\n    }\n    if (target !== this) {\n      this.indicatorEl.hidden = true;\n    }\n  }\n\n  onDrop(event) {\n    this.#dropTargetInfo = this.getDropTargetInfo(event);\n    if (!this.#draggedElement || !this.#dropTargetInfo) {\n      return;\n    }\n\n    // Don't emit the reorder event if the dragged element is dropped on itself\n    if (this.#draggedElement === this.#dropTargetInfo.targetElement) {\n      this.onDragEnd();\n      return;\n    }\n\n    // Don't emit the reorder event if inserting after the previous element\n    // or before the next element (no actual reordering needed)\n    const draggedIndex = this.getItemIndex(this.#draggedElement);\n    const targetIndex = this.#dropTargetInfo.targetIndex;\n    const position = this.#dropTargetInfo.position;\n\n    if (\n      (position === 0 && targetIndex === draggedIndex - 1) || // Inserting after previous element\n      (position === -1 && targetIndex === draggedIndex + 1) // Inserting before next element\n    ) {\n      this.onDragEnd();\n      return;\n    }\n\n    event.preventDefault();\n    event.stopPropagation();\n    this.emitEvent(REORDER_EVENT, {\n      draggedElement: this.#draggedElement,\n      targetElement: this.#dropTargetInfo.targetElement,\n      position: this.#dropTargetInfo.position,\n      draggedIndex,\n      targetIndex,\n    });\n    this.onDragEnd();\n  }\n\n  onDragEnd() {\n    // Sometimes dragend is not fired when the element is dropped. To ensure that\n    // we clean up, onDragEnd is also called from onDrop; so it might be called\n    // multiple times.\n    if (this.#draggedElement == null) {\n      return;\n    }\n    this.emitEvent(DRAGEND_EVENT, {\n      draggedElement: this.#draggedElement,\n    });\n    this.indicatorEl.hidden = true;\n    this.#draggedElement = null;\n  }\n\n  evaluateKeyDownEvent(event) {\n    const direction = isReorderKeyboardEvent(event);\n    if (direction == 0) {\n      return undefined;\n    }\n    const fromEl = this.getTargetItemFromEvent(event);\n    if (!fromEl) {\n      return undefined;\n    }\n    const fromIndex = this.getItemIndex(fromEl);\n    if (fromIndex === -1) {\n      return undefined;\n    }\n\n    // if index is 0 and direction is -1, or index is last and direction is 1, do nothing\n    const items = this.#items;\n    if (\n      (fromIndex === 0 && direction === -1) ||\n      (fromIndex === items.length - 1 && direction === 1)\n    ) {\n      return undefined;\n    }\n\n    return {\n      draggedElement: fromEl,\n      targetElement: items[fromIndex + direction],\n      position: Math.min(direction, 0),\n    };\n  }\n\n  /**\n   * Creates a CustomEvent and dispatches it on the element.\n   *\n   * @param {string} eventName The name of the event\n   * @param {object} [detail] The detail object to pass to the event\n   */\n  emitEvent(eventName, detail) {\n    const customEvent = new CustomEvent(eventName, {\n      detail,\n    });\n    this.dispatchEvent(customEvent);\n  }\n\n  /**\n   * Returns all draggable items based on the itemSelector. Adds reorderable\n   * indices and ensures elements are draggable.\n   *\n   * @see getAssignedElementsBySelector for parameters\n   */\n  getItems() {\n    let items = this.getAssignedElementsBySelector(this.itemSelector);\n    this.addDraggableAttribute(items);\n    items.forEach((item, i) => {\n      item[REORDER_PROP] = i;\n    });\n    this.#items = items;\n  }\n\n  /**\n   * Returns all elements for the given selector, including the elements\n   * themselves, matching the selector, regardless of nesting\n   *\n   * @param {string} selector The selector to match\n   * @param {HTMLElement | HTMLElement[]} [root] The elements to start\n   *   searching for items. Defaults to the slot.\n   */\n  getAssignedElementsBySelector(selector, root) {\n    if (!root) {\n      root = this.slotEl.assignedElements();\n    } else if (!Array.isArray(root)) {\n      root = [root];\n    }\n\n    const collectEls = items => {\n      return items.flatMap(item => {\n        if (item.matches(selector)) {\n          return item;\n        }\n\n        let nestedEls =\n          item.shadowRoot?.querySelectorAll(selector) ??\n          item.querySelectorAll(selector);\n        if (nestedEls.length) {\n          return [...nestedEls];\n        }\n\n        let nextEls =\n          item.localName == \"slot\" ? item.assignedElements() : item.children;\n        return collectEls([...(nextEls ?? [])]);\n      });\n    };\n\n    return collectEls(root);\n  }\n\n  /**\n   * Returns the drop target based on the current mouse position relative to\n   * the item it hovers over\n   */\n  getDropTargetInfo(event) {\n    const targetItem = this.getTargetItemFromEvent(event);\n    if (!targetItem) {\n      return null;\n    }\n\n    const targetIndex = this.getItemIndex(targetItem);\n    if (targetIndex === -1) {\n      return null;\n    }\n\n    const rect = targetItem.getBoundingClientRect();\n\n    const threshold = rect.height * 0.5;\n    const position = event.clientY < rect.top + threshold ? -1 : 0;\n    return {\n      targetElement: targetItem,\n      targetIndex,\n      position,\n    };\n  }\n\n  /**\n   * Returns the index of the given item element out of all items within the\n   * slot\n   */\n  getItemIndex(item) {\n    return item[REORDER_PROP] ?? -1;\n  }\n\n  /**\n   * Returns the item element that is the closest parent of the given event\n   * target\n   */\n  getTargetItemFromEvent(event) {\n    const targetItem =\n      event.target.closest(this.itemSelector) ||\n      event.originalTarget.closest(this.itemSelector);\n    return targetItem;\n  }\n\n  render() {\n    return html`\n      <link\n        rel=\"stylesheet\"\n        href=\"${__chrome_styles_loader__mozreorderablelistStyles}\"\n      />\n      <div class=\"indicator\" hidden=\"\" aria-hidden=\"true\"></div>\n      <slot @slotchange=${this.getItems}></slot>\n    `;\n  }\n}\n\n/**\n * Checks if the given keyboard event is a reorder keyboard event\n * (ctrl+shift+up/down).\n *\n * Can be used instead of the automatic reorder keyboard event handling by the\n * moz-reorderable-list component.\n *\n * @param {KeyboardEvent} event - The keyboard event to check\n * @returns {0 | -1 | 1} - 0 if the event is not a reorder keyboard event, -1\n *   if the event is a reorder up event, 1 if the event is a reorder down\n *   event\n */\nexport function isReorderKeyboardEvent(event) {\n  if (event.code != \"ArrowUp\" && event.code != \"ArrowDown\") {\n    return 0;\n  }\n  if (!event.ctrlKey || !event.shiftKey || event.altKey || event.metaKey) {\n    return 0;\n  }\n  return event.code == \"ArrowUp\" ? -1 : 1;\n}\n\ncustomElements.define(\"moz-reorderable-list\", MozReorderableList);\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nimport { LitElement, html, ifDefined } from \"../vendor/lit.all.mjs\";\n// eslint-disable-next-line import/no-unassigned-import\nimport \"./moz-reorderable-list.mjs\";\n\nconst DEFAULT = \"Default\";\nconst SHADOW_DOM = \"Shadow DOM\";\nconst DRAG_SELECTOR = \"Drag selector\";\n\nexport default {\n  title: \"UI Widgets/Reorderable List\",\n  component: \"moz-reorderable-list\",\n  argTypes: {\n    demoType: {\n      options: [DEFAULT, SHADOW_DOM, DRAG_SELECTOR],\n      control: { type: \"select\" },\n    },\n  },\n  parameters: {\n    status: \"in-development\",\n    actions: {\n      handles: [\"reorder\"],\n    },\n  },\n};\n\nclass ShadowDemo extends LitElement {\n  static shadowRootOptions = {\n    ...LitElement.shadowRootOptions,\n    delegatesFocus: true,\n  };\n\n  static properties = {\n    item: { type: String },\n  };\n\n  render() {\n    return html`<style>\n        #shadowed {\n          border: var(--border-width) solid var(--border-color);\n          border-radius: var(--border-radius-small);\n          background-color: var(--background-color-box);\n          display: flex;\n          align-items: center;\n          padding: var(--space-small);\n        }\n      </style>\n      <button id=\"shadowed\">${this.item}</button>`;\n  }\n}\ncustomElements.define(\"shadow-demo\", ShadowDemo);\n\nclass ReorderableDemo extends LitElement {\n  static properties = {\n    items: { type: Array, state: true },\n    type: { type: String },\n  };\n\n  // Choosing not to use Shadow DOM here for demo purposes.\n  createRenderRoot() {\n    return this;\n  }\n\n  constructor() {\n    super();\n    this.items = [\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\"];\n  }\n\n  async reorderItems(draggedElement, targetElement, before = false) {\n    const draggedIndex = this.items.indexOf(draggedElement.textContent.trim());\n    const targetIndex = this.items.indexOf(targetElement.textContent.trim());\n\n    let nextItems = [...this.items];\n    const [draggedItem] = nextItems.splice(draggedIndex, 1);\n\n    let adjustedTargetIndex = targetIndex;\n    if (draggedIndex < targetIndex) {\n      adjustedTargetIndex--;\n    }\n\n    if (!before) {\n      adjustedTargetIndex = adjustedTargetIndex + 1;\n    }\n    nextItems.splice(adjustedTargetIndex, 0, draggedItem);\n\n    this.items = nextItems;\n    await this.updateComplete;\n    let movedItem = this.querySelectorAll(\"li\")[adjustedTargetIndex];\n    let focusableEl = this.getFocusableEl(movedItem);\n    focusableEl?.focus();\n  }\n\n  getFocusableEl(item) {\n    if (this.type == DRAG_SELECTOR) {\n      return item.querySelector(this.selectors.dragSelector);\n    }\n\n    // Look for shadow DOM first, fallback to firstElementChild\n    return (\n      item.shadowRoot?.querySelector(this.selectors.itemSelector) ??\n      item.firstElementChild\n    );\n  }\n\n  handleReorder(e) {\n    const { draggedElement, targetElement, position } = e.detail;\n    this.reorderItems(draggedElement, targetElement, position === -1);\n  }\n\n  handleKeydown(e) {\n    e.stopPropagation();\n    const result = this.children[1].evaluateKeyDownEvent(e);\n    if (!result) {\n      return;\n    }\n    this.handleReorder({ detail: result });\n  }\n\n  addItem() {\n    this.items = [...this.items, `Item ${this.items.length + 1}`];\n  }\n\n  get selectors() {\n    switch (this.type) {\n      case DEFAULT:\n        return { itemSelector: \"li\" };\n      case SHADOW_DOM:\n        return { itemSelector: \"#shadowed\" };\n      case DRAG_SELECTOR:\n        return { itemSelector: \"li\", dragSelector: \".handle\" };\n      default:\n        return {};\n    }\n  }\n\n  contentTemplate(item) {\n    if (this.type == DEFAULT) {\n      return html`<button>${item}</button>`;\n    } else if (this.type == DRAG_SELECTOR) {\n      return html`<div class=\"draggable\">\n        <div class=\"handle\" tabindex=\"0\"></div>\n        <span>${item}</span>\n      </div>`;\n    }\n    return html`<shadow-demo item=${item}></shadow-demo>`;\n  }\n\n  render() {\n    let { itemSelector, dragSelector } = this.selectors;\n    return html`\n      <style>\n        ul {\n          padding: 0;\n          display: flex;\n          flex-direction: column;\n          gap: var(--space-small);\n        }\n        li {\n          list-style: none;\n        }\n        .handle {\n          width: var(--button-size-icon);\n          height: var(--button-size-icon);\n          cursor: pointer;\n          background-image: url(\"chrome://global/skin/icons/more.svg\");\n          background-position: center;\n          background-repeat: no-repeat;\n          border-radius: var(--button-border-radius);\n          -moz-context-properties: fill;\n          fill: currentColor;\n        }\n        .draggable {\n          border: var(--border-width) solid var(--border-color);\n          border-radius: var(--border-radius-small);\n          background-color: var(--background-color-box);\n          display: flex;\n          align-items: center;\n          gap: var(--space-small);\n        }\n      </style>\n      <moz-reorderable-list\n        itemselector=${ifDefined(itemSelector)}\n        dragselector=${ifDefined(dragSelector)}\n        @reorder=${this.handleReorder}\n        @keydown=${this.handleKeydown}\n      >\n        <ul>\n          ${this.items.map(\n            item => html` <li>${this.contentTemplate(item)}</li> `\n          )}\n        </ul>\n      </moz-reorderable-list>\n      <button @click=${this.addItem}>Add another item</button>\n    `;\n  }\n}\ncustomElements.define(\"reorderable-demo\", ReorderableDemo);\n\nconst Template = ({ demoType }) => html`\n  <reorderable-demo type=${demoType}></reorderable-demo>\n`;\n\nexport const Default = Template.bind({});\nDefault.args = {\n  demoType: DEFAULT,\n};\n\nexport const ShadowDOM = Template.bind({});\nShadowDOM.args = {\n  demoType: SHADOW_DOM,\n};\n\nexport const DragSelector = Template.bind({});\nDragSelector.args = {\n  demoType: DRAG_SELECTOR,\n};\n"],"names":[],"sourceRoot":""}