{"version":3,"file":"1424.8d313417.iframe.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAKA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA","sources":["webpack:///../../../toolkit/content/widgets/moz-reorderable-list/moz-reorderable-list.mjs"],"sourcesContent":["import __chrome_styles_loader__mozreorderablelistStyles from \"toolkit/content/widgets/moz-reorderable-list/moz-reorderable-list.css\";\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nimport { html } from \"../vendor/lit.all.mjs\";\nimport { MozLitElement } from \"../lit-utils.mjs\";\n\nconst REORDER_EVENT = \"reorder\";\nconst DRAGSTART_EVENT = \"dragstarted\";\nconst DRAGEND_EVENT = \"dragended\";\nconst DRAG_DATA_TYPE_PREFIX = \"text/reorderable-item/\";\nconst REORDER_PROP = \"__mozReorderableIndex\";\n\n/**\n * A wrapper element that allows its children to be reordered by dragging and\n * dropping. The element emits the custom `reorder` event when an item is\n * dropped in a new position, which you can use to perform the actual\n * reordering.\n *\n * The detail object of the `reorder` event contains the following properties:\n *\n * - `draggedElement`: The element that was dragged.\n * - `targetElement`: The element over which the dragged element was dropped.\n * - `position`: The position of the drop relative to the target element. -1\n *   means before, 0 means after.\n *\n * Which children are reorderable is determined by the `itemSelector` property.\n *\n * Things to keep in mind when using this element:\n *\n * - Preserve the focus when reordering items.\n * - Check that the reordering shortcuts are not in conflict with other\n *   shortcuts.\n * - Make sure that reordering is picked up by screen readers. Usually DOM\n *   updates cause the reordered element to be read out again, which is\n *   sufficient.\n *\n * @tagname moz-reorderable-list\n * @property {string} itemSelector - Selector for elements that should be\n *   reorderable.\n * @fires reorder - Fired when an item is dropped in a new position.\n * @fires dragstarted - Fired when an item is dragged.\n * @fires dragended - Fired when an item is dropped.\n */\nexport default class MozReorderableList extends MozLitElement {\n  static queries = {\n    slotEl: \"slot\",\n    indicatorEl: \".indicator\",\n  };\n\n  static properties = {\n    itemSelector: { type: String },\n  };\n\n  #draggedElement = null;\n  #dropTargetInfo = null;\n  #mutationObserver = null;\n  #items = [];\n\n  isXULElement(element) {\n    return window.XULElement?.isInstance?.(element);\n  }\n\n  getBounds(element) {\n    return (\n      window.windowUtils?.getBoundsWithoutFlushing?.(element) ||\n      element.getBoundingClientRect()\n    );\n  }\n\n  constructor() {\n    super();\n    this.itemSelector = \"li\";\n    this.addEventListener(\"dragstart\", this.onDragStart);\n    this.addEventListener(\"dragover\", this.onDragOver);\n    this.addEventListener(\"dragleave\", this.onDragLeave);\n    this.addEventListener(\"dragend\", this.onDragEnd);\n    this.addEventListener(\"drop\", this.onDrop);\n    this.#mutationObserver = new MutationObserver((...args) =>\n      this.onMutation(...args)\n    );\n  }\n\n  firstUpdated() {\n    super.firstUpdated();\n    this.getItems();\n    this.addDraggableAttribute();\n  }\n\n  connectedCallback() {\n    super.connectedCallback();\n    this.#mutationObserver.observe(this, {\n      childList: true,\n      subtree: true,\n    });\n  }\n\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    this.#mutationObserver.disconnect();\n  }\n\n  onMutation(mutationList) {\n    let needsUpdate = false;\n\n    for (const mutation of mutationList) {\n      if (mutation.addedNodes.length || mutation.removedNodes.length) {\n        needsUpdate = true;\n      }\n\n      for (const addedNode of mutation.addedNodes) {\n        if (addedNode.nodeType === Node.ELEMENT_NODE) {\n          this.addDraggableAttribute(addedNode);\n        }\n      }\n    }\n\n    if (needsUpdate) {\n      this.getItems();\n    }\n  }\n\n  /**\n   * Add the draggable attribute to all items that match the selector.\n   *\n   * @see getItems for information about the root parameter.\n   */\n  addDraggableAttribute(root) {\n    let items = root\n      ? this.getAssignedElementsBySelector(this.itemSelector, root)\n      : this.#items;\n    for (const item of items) {\n      // Unlike XUL elements, HTML elements are not draggable by default.\n      // So we need to set the draggable attribute on all items that match the selector.\n      if (!this.isXULElement(item)) {\n        item.draggable = true;\n      }\n    }\n  }\n\n  onDragStart(event) {\n    let draggedElement = event.target.closest(this.itemSelector);\n    if (!draggedElement) {\n      return;\n    }\n\n    const dragIndex = this.getItemIndex(draggedElement);\n    if (dragIndex === -1) {\n      return;\n    }\n\n    event.stopPropagation();\n\n    this.emitEvent(DRAGSTART_EVENT, {\n      draggedElement,\n    });\n\n    // XUL elements need dataTransfer values to be set for drag and drop to work.\n    if (this.isXULElement(draggedElement)) {\n      let documentId = draggedElement.ownerDocument.documentElement.id;\n      event.dataTransfer.mozSetDataAt(\n        `${DRAG_DATA_TYPE_PREFIX}${documentId}`,\n        draggedElement.id,\n        0\n      );\n      event.dataTransfer.addElement(draggedElement);\n      event.dataTransfer.effectAllowed = \"move\";\n    }\n\n    this.#draggedElement = draggedElement;\n  }\n\n  onDragOver(event) {\n    this.#dropTargetInfo = this.getDropTargetInfo(event);\n    if (!this.#dropTargetInfo) {\n      this.indicatorEl.hidden = true;\n      return;\n    }\n    event.preventDefault();\n    event.stopPropagation();\n    const { targetIndex, position } = this.#dropTargetInfo;\n    const items = this.#items;\n    const item = items[targetIndex];\n\n    if (!item) {\n      this.indicatorEl.hidden = true;\n      return;\n    }\n\n    const containerRect = this.getBounds(this);\n    const itemRect = this.getBounds(item);\n\n    this.indicatorEl.hidden = false;\n    if (position < 0) {\n      this.indicatorEl.style.top = `${itemRect.top - containerRect.top}px`;\n    } else {\n      this.indicatorEl.style.top = `${itemRect.bottom - containerRect.top}px`;\n    }\n  }\n\n  onDragLeave(event) {\n    if (!event.target.matches(this.itemSelector)) {\n      return;\n    }\n    let target = event.relatedTarget;\n    while (target && target !== this) {\n      target = target.parentNode;\n    }\n    if (target !== this) {\n      this.indicatorEl.hidden = true;\n    }\n  }\n\n  onDrop(event) {\n    this.#dropTargetInfo = this.getDropTargetInfo(event);\n    if (!this.#draggedElement || !this.#dropTargetInfo) {\n      return;\n    }\n\n    // Don't emit the reorder event if the dragged element is dropped on itself\n    if (this.#draggedElement === this.#dropTargetInfo.targetElement) {\n      this.onDragEnd();\n      return;\n    }\n\n    // Don't emit the reorder event if inserting after the previous element\n    // or before the next element (no actual reordering needed)\n    const draggedIndex = this.getItemIndex(this.#draggedElement);\n    const targetIndex = this.#dropTargetInfo.targetIndex;\n    const position = this.#dropTargetInfo.position;\n\n    if (\n      (position === 0 && targetIndex === draggedIndex - 1) || // Inserting after previous element\n      (position === -1 && targetIndex === draggedIndex + 1) // Inserting before next element\n    ) {\n      this.onDragEnd();\n      return;\n    }\n\n    event.preventDefault();\n    event.stopPropagation();\n    this.emitEvent(REORDER_EVENT, {\n      draggedElement: this.#draggedElement,\n      targetElement: this.#dropTargetInfo.targetElement,\n      position: this.#dropTargetInfo.position,\n      draggedIndex,\n      targetIndex,\n    });\n    this.onDragEnd();\n  }\n\n  onDragEnd() {\n    // Sometimes dragend is not fired when the element is dropped. To ensure that\n    // we clean up, onDragEnd is also called from onDrop; so it might be called\n    // multiple times.\n    if (this.#draggedElement == null) {\n      return;\n    }\n    this.emitEvent(DRAGEND_EVENT, {\n      draggedElement: this.#draggedElement,\n    });\n    this.indicatorEl.hidden = true;\n    this.#draggedElement = null;\n  }\n\n  evaluateKeyDownEvent(event) {\n    const direction = isReorderKeyboardEvent(event);\n    if (direction == 0) {\n      return undefined;\n    }\n    const fromEl = this.getTargetItemFromEvent(event);\n    if (!fromEl) {\n      return undefined;\n    }\n    const fromIndex = this.getItemIndex(fromEl);\n    if (fromIndex === -1) {\n      return undefined;\n    }\n\n    // if index is 0 and direction is -1, or index is last and direction is 1, do nothing\n    const items = this.#items;\n    if (\n      (fromIndex === 0 && direction === -1) ||\n      (fromIndex === items.length - 1 && direction === 1)\n    ) {\n      return undefined;\n    }\n\n    return {\n      draggedElement: fromEl,\n      targetElement: items[fromIndex + direction],\n      position: Math.min(direction, 0),\n    };\n  }\n\n  /**\n   * Creates a CustomEvent and dispatches it on the element.\n   *\n   * @param {string} eventName The name of the event\n   * @param {Object} [detail] The detail object to pass to the event\n   */\n  emitEvent(eventName, detail) {\n    const customEvent = new CustomEvent(eventName, {\n      detail,\n    });\n    this.dispatchEvent(customEvent);\n  }\n\n  /**\n   * Returns all draggable items based on the itemSelector\n   *\n   * @see getAssignedElementsBySelector for parameters\n   */\n  getItems() {\n    let items = this.getAssignedElementsBySelector(this.itemSelector);\n    items.forEach((item, i) => (item[REORDER_PROP] = i));\n    this.#items = items;\n  }\n\n  /**\n   * Returns all elements for the given selector, including the elements\n   * themselves, matching the selector, regardless of nesting\n   *\n   * @param {string} selector The selector to match\n   * @param {HTMLElement | HTMLElement[]} [root] The elements to start\n   *   searching for items. Defaults to the slot.\n   */\n  getAssignedElementsBySelector(selector, root) {\n    if (!root) {\n      root = this.slotEl.assignedElements();\n    } else if (!Array.isArray(root)) {\n      root = [root];\n    }\n\n    return root.reduce((acc, item) => {\n      if (item.matches(selector)) {\n        acc.push(item);\n      } else {\n        acc.push(...item.querySelectorAll(selector));\n      }\n      return acc;\n    }, []);\n  }\n\n  /**\n   * Returns the drop target based on the current mouse position relative to\n   * the item it hovers over\n   */\n  getDropTargetInfo(event) {\n    const targetItem = this.getTargetItemFromEvent(event);\n    if (!targetItem) {\n      return null;\n    }\n\n    const targetIndex = this.getItemIndex(targetItem);\n    if (targetIndex === -1) {\n      return null;\n    }\n\n    const rect = targetItem.getBoundingClientRect();\n\n    const threshold = rect.height * 0.5;\n    const position = event.clientY < rect.top + threshold ? -1 : 0;\n    return {\n      targetElement: targetItem,\n      targetIndex,\n      position,\n    };\n  }\n\n  /**\n   * Returns the index of the given item element out of all items within the\n   * slot\n   */\n  getItemIndex(item) {\n    return item[REORDER_PROP] ?? -1;\n  }\n\n  /**\n   * Returns the item element that is the closest parent of the given event\n   * target\n   */\n  getTargetItemFromEvent(event) {\n    const target = event.target;\n    const targetItem = target.closest(this.itemSelector);\n    return targetItem;\n  }\n\n  render() {\n    return html`\n      <link\n        rel=\"stylesheet\"\n        href=\"${__chrome_styles_loader__mozreorderablelistStyles}\"\n      />\n      <div class=\"indicator\" hidden=\"\" aria-hidden=\"true\"></div>\n      <slot @slotchange=${this.getItems}></slot>\n    `;\n  }\n}\n\n/**\n * Checks if the given keyboard event is a reorder keyboard event\n * (ctrl+shift+up/down).\n *\n * Can be used instead of the automatic reorder keyboard event handling by the\n * moz-reorderable-list component.\n *\n * @param {KeyboardEvent} event - The keyboard event to check\n * @returns {0 | -1 | 1} - 0 if the event is not a reorder keyboard event, -1\n *   if the event is a reorder up event, 1 if the event is a reorder down\n *   event\n */\nexport function isReorderKeyboardEvent(event) {\n  if (event.code != \"ArrowUp\" && event.code != \"ArrowDown\") {\n    return 0;\n  }\n  if (!event.ctrlKey || !event.shiftKey || event.altKey || event.metaKey) {\n    return 0;\n  }\n  return event.code == \"ArrowUp\" ? -1 : 1;\n}\n\ncustomElements.define(\"moz-reorderable-list\", MozReorderableList);\n"],"names":[],"sourceRoot":""}