{"version":3,"file":"moz-box-group-moz-box-group-stories.354693e8.iframe.bundle.js","mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACA;;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AChLA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/VA;AACA;AACA;;AAEA;AAOA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACpIA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5NA;AACA;AACA;;AAEA;AASA;AAIA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAGA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;;AAKA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1dA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack:///../../../toolkit/content/widgets/moz-input-folder/moz-input-folder.mjs","webpack:///../../../toolkit/content/widgets/moz-box-group/moz-box-group.stories.mjs","webpack:///../preferences/widgets/setting-element/setting-element.mjs","webpack:///../../../toolkit/content/widgets/moz-box-group/moz-box-group.mjs","webpack:///../preferences/widgets/setting-control/setting-control.mjs","webpack:///../../../toolkit/content/widgets/moz-input-text/moz-input-text.mjs"],"sourcesContent":["import __chrome_styles_loader__mozinputfolderStyles from \"toolkit/content/widgets/moz-input-folder/moz-input-folder.css\";\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nimport { html, classMap, styleMap } from \"../vendor/lit.all.mjs\";\nimport MozInputText from \"chrome://global/content/elements/moz-input-text.mjs\";\n\nwindow.MozXULElement?.insertFTLIfNeeded(\"toolkit/global/mozInputFolder.ftl\");\n\n/**\n * An input folder custom element.\n *\n * @tagname moz-input-folder\n *\n * @property {string} label - The text of the label element\n * @property {string} name - The name of the input control\n * @property {string} value - The path to the selected folder\n * @property {boolean} disabled - The disabled state of the component\n * @property {string} iconSrc - The src for an optional icon in the label\n * @property {string} description - The text for the description element that helps describe the input control\n * @property {string} supportPage - Name of the SUMO support page to link to.\n * @property {string} placeholder - Text to display when the input has no value.\n * @property {string} displayValue - The value of the input control if it's different from the component value.\n * @property {string} dialogTitle - Text to display as a file picker dialog title.\n * @property {object} folder - The file object that represents the selected folder.\n */\n\nexport default class MozInputFolder extends MozInputText {\n  #folder;\n\n  static properties = {\n    displayValue: { type: String },\n    dialogTitle: { type: String, fluent: true },\n    _inputIconSrc: { type: String, state: true },\n  };\n\n  static queries = {\n    chooseFolderButtonEl: \"#choose-folder-button\",\n  };\n\n  constructor() {\n    super();\n    this.readonly = true;\n    this.displayValue = \"\";\n    this.dialogTitle = \"\";\n    this._inputIconSrc = \"\";\n    this.#folder = null;\n  }\n\n  willUpdate(changedProperties) {\n    super.willUpdate(changedProperties);\n\n    if (changedProperties.has(\"readonly\")) {\n      this.readonly = true;\n    }\n    if (changedProperties.has(\"value\")) {\n      if (this.value == \"\") {\n        this.#folder = null;\n        this._inputIconSrc = \"\";\n      } else if (!this.#folder || this.value != this.#folder.path) {\n        let currentValue = this.value;\n        this.getFolderFromPath(this.value).then(folder => {\n          if (this.value === currentValue) {\n            this.#folder = folder;\n            this._inputIconSrc = this.getInputIconSrc(this.#folder);\n          }\n        });\n      } else {\n        this._inputIconSrc = this.getInputIconSrc(this.#folder);\n      }\n    }\n  }\n\n  get folder() {\n    return this.#folder;\n  }\n\n  hasServices() {\n    // Safely check for Services without throwing a ReferenceError.\n    return typeof Services !== \"undefined\";\n  }\n\n  async getFolderFromPath(path) {\n    let folder = null;\n    try {\n      folder = await IOUtils.getDirectory(path);\n    } catch (e) {\n      //Not a valid path\n      console.error(\n        \"The error occurred while attempting to get directory from the moz-input-folder value\"\n      );\n    }\n\n    return folder;\n  }\n\n  getInputIconSrc(folder) {\n    if (!folder || !this.hasServices()) {\n      let defaultIconSrc = \"chrome://global/skin/icons/folder.svg\";\n      return defaultIconSrc;\n    }\n\n    let fph = Services.io\n      .getProtocolHandler(\"file\")\n      .QueryInterface(Ci.nsIFileProtocolHandler);\n    let iconUrlSpec = fph.getURLSpecFromDir(folder);\n    let inputIconSrc = \"moz-icon://\" + iconUrlSpec + \"?size=16\";\n    return inputIconSrc;\n  }\n\n  async openFolderPicker() {\n    let folderPicker = Cc[\"@mozilla.org/filepicker;1\"].createInstance(\n      Ci.nsIFilePicker\n    );\n    let mode = Ci.nsIFilePicker.modeGetFolder;\n    folderPicker.init(window.browsingContext, this.dialogTitle, mode);\n    folderPicker.appendFilters(Ci.nsIFilePicker.filterAll);\n\n    if (this.#folder && (await IOUtils.exists(this.#folder.path))) {\n      folderPicker.displayDirectory = this.#folder;\n    }\n\n    let result = await new Promise(resolve => folderPicker.open(resolve));\n    if (\n      result != Ci.nsIFilePicker.returnOK ||\n      this.value == folderPicker.file.path\n    ) {\n      if (Cu.isInAutomation) {\n        // Dispatch a test-only event so we can tell that the dialog is closing.\n        this.dispatchEvent(new CustomEvent(\"moz-input-folder-picker-close\"));\n      }\n\n      return;\n    }\n\n    this.#folder = folderPicker.file;\n    this.value = this.#folder.path;\n\n    this.dispatchEvent(new Event(\"input\", { bubbles: true }));\n    this.dispatchEvent(new Event(\"change\", { bubbles: true }));\n  }\n\n  inputStylesTemplate() {\n    return html`<link\n      rel=\"stylesheet\"\n      href=\"${__chrome_styles_loader__mozinputfolderStyles}\"\n    />`;\n  }\n\n  inputTemplate() {\n    let inputValue = this.displayValue || this.value;\n    let classes, styles;\n    if (this._inputIconSrc) {\n      classes = classMap({\n        \"with-icon\": true,\n      });\n      styles = styleMap({\n        \"--input-background-icon\": `url(${this._inputIconSrc})`,\n      });\n    }\n\n    return html`\n      <div class=\"container\">\n        ${super.inputTemplate({ classes, styles, inputValue })}\n        <moz-button\n          id=\"choose-folder-button\"\n          data-l10n-id=\"choose-folder-button\"\n          data-l10n-attrs=\"accesskey\"\n          ?disabled=${this.disabled || this.parentDisabled}\n          @click=${this.openFolderPicker}\n        ></moz-button>\n      </div>\n    `;\n  }\n}\ncustomElements.define(\"moz-input-folder\", MozInputFolder);\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nimport { html, ifDefined } from \"../vendor/lit.all.mjs\";\nimport { GROUP_TYPES } from \"./moz-box-group.mjs\";\n// eslint-disable-next-line mozilla/no-browser-refs-in-toolkit\nimport \"chrome://browser/content/preferences/widgets/setting-control.mjs\";\n\nexport default {\n  title: \"UI Widgets/Box Group\",\n  component: \"moz-box-group\",\n  argTypes: {\n    type: {\n      options: Object.keys(GROUP_TYPES),\n      mapping: GROUP_TYPES,\n      control: \"select\",\n    },\n  },\n  parameters: {\n    status: \"in-development\",\n    fluent: `\nmoz-box-item =\n  .label = I'm a box item\n  .description = I'm part of a group\nmoz-box-button-1 =\n  .label = I'm a box button in a group\nmoz-box-button-2 =\n  .label = I'm another box button in a group\nmoz-box-link =\n  .label = I'm a box link in a group\nmoz-box-delete-action =\n  .title = Delete I'm a box item\nmoz-box-edit-action =\n  .title = Edit I'm a box item\nmoz-box-toggle-action =\n  .aria-label = Toggle I'm a box item\nmoz-box-more-action =\n  .title = More options, I'm a box item\nmoz-box-item-reorderable-1 =\n  .label = I'm box item number 1\nmoz-box-item-reorderable-2 =\n  .label = I'm box item number 2\nmoz-box-item-reorderable-3 =\n  .label = I'm box item number 3\nmoz-box-item-reorderable-4 =\n  .label = I'm box item number 4\nmoz-box-item-reorderable-5 =\n  .label = I'm box item number 5\nmoz-box-item-header =\n  .label = I'm a header box item\nmoz-box-button-footer =\n  .label = I'm a footer box button\n    `,\n  },\n};\n\nfunction basicTemplate({ type, hasHeader, hasFooter, wrapped }) {\n  return html`<moz-box-group type=${ifDefined(type)}>\n      ${hasHeader\n        ? html`<moz-box-item\n            slot=\"header\"\n            data-l10n-id=\"moz-box-item-header\"\n          ></moz-box-item>`\n        : \"\"}\n      ${getInnerElements(type, wrapped)}\n      ${hasFooter\n        ? html`<moz-box-button\n            slot=\"footer\"\n            data-l10n-id=\"moz-box-button-footer\"\n          ></moz-box-button>`\n        : \"\"}\n    </moz-box-group>\n    ${type == \"list\"\n      ? html`<moz-button class=\"delete\" @click=${appendItem}>\n          Add an item\n        </moz-button>`\n      : \"\"}`;\n}\n\nfunction getInnerElements(type) {\n  if (type == GROUP_TYPES.reorderable) {\n    return reorderableElements();\n  }\n\n  return basicElements();\n}\n\nfunction reorderableElements() {\n  return Array.from({ length: 5 }).map((_, i) => {\n    return html`<moz-box-item\n      data-l10n-id=${`moz-box-item-reorderable-${i + 1}`}\n    >\n      <moz-button\n        iconsrc=\"chrome://global/skin/icons/edit-outline.svg\"\n        data-l10n-id=\"moz-box-edit-action\"\n        slot=\"actions-start\"\n      ></moz-button>\n      <moz-toggle\n        slot=\"actions\"\n        pressed\n        data-l10n-id=\"moz-box-toggle-action\"\n      ></moz-toggle>\n    </moz-box-item>`;\n  });\n}\n\nfunction basicElements() {\n  return html`<moz-box-item data-l10n-id=\"moz-box-item\">\n      <moz-button\n        iconsrc=\"chrome://global/skin/icons/edit-outline.svg\"\n        data-l10n-id=\"moz-box-edit-action\"\n        type=\"ghost\"\n        slot=\"actions\"\n      ></moz-button>\n      <moz-toggle\n        slot=\"actions\"\n        pressed\n        data-l10n-id=\"moz-box-toggle-action\"\n      ></moz-toggle>\n      <moz-button\n        iconsrc=\"chrome://global/skin/icons/more.svg\"\n        data-l10n-id=\"moz-box-more-action\"\n        slot=\"actions-start\"\n      ></moz-button>\n    </moz-box-item>\n    <moz-box-link data-l10n-id=\"moz-box-link\"></moz-box-link>\n    <moz-box-button data-l10n-id=\"moz-box-button-1\"></moz-box-button>\n    <moz-box-item data-l10n-id=\"moz-box-item\">\n      <moz-button\n        iconsrc=\"chrome://global/skin/icons/edit-outline.svg\"\n        data-l10n-id=\"moz-box-edit-action\"\n        type=\"ghost\"\n        slot=\"actions-start\"\n      ></moz-button>\n      <moz-button\n        iconsrc=\"chrome://global/skin/icons/more.svg\"\n        data-l10n-id=\"moz-box-more-action\"\n        slot=\"actions-start\"\n      ></moz-button>\n    </moz-box-item>\n    <moz-box-button data-l10n-id=\"moz-box-button-2\"></moz-box-button>`;\n}\n\nconst appendItem = event => {\n  let group = event.target.getRootNode().querySelector(\"moz-box-group\");\n\n  let boxItem = document.createElement(\"moz-box-item\");\n  boxItem.label = \"New box item\";\n  boxItem.description = \"New items are added to the list\";\n\n  let actionButton = document.createElement(\"moz-button\");\n  actionButton.addEventListener(\"click\", () => boxItem.remove());\n  actionButton.iconSrc = \"chrome://global/skin/icons/delete.svg\";\n  actionButton.slot = \"actions\";\n  actionButton.setAttribute(\"data-l10n-id\", \"moz-box-delete-action\");\n  boxItem.append(actionButton);\n\n  group.prepend(boxItem);\n};\n\n// Example with all child elements wrapped in setting-control/setting-group,\n// which is the most common use case in Firefox preferences.\nfunction wrappedTemplate({ type, hasHeader, hasFooter }) {\n  return html`<setting-control\n    .config=${getConfig({ type, hasHeader, hasFooter })}\n    .setting=${DEFAULT_SETTING}\n    .getSetting=${getSetting}\n  ></setting-control>`;\n}\n\nconst getConfig = ({ type, hasHeader, hasFooter }) => ({\n  id: \"exampleWrapped\",\n  control: \"moz-box-group\",\n  controlAttrs: {\n    type,\n  },\n  items: [\n    ...(hasHeader\n      ? [\n          {\n            id: \"header\",\n            control: \"moz-box-item\",\n            l10nId: \"moz-box-item-header\",\n            controlAttrs: { slot: \"header \" },\n          },\n        ]\n      : []),\n    {\n      id: \"item1\",\n      control: \"moz-box-item\",\n      l10nId: \"moz-box-item\",\n      options: [\n        {\n          id: \"slotted-button\",\n          control: \"moz-button\",\n          l10nId: \"moz-box-edit-action\",\n          iconSrc: \"chrome://global/skin/icons/edit-outline.svg\",\n          controlAttrs: {\n            type: \"ghost\",\n            slot: \"actions\",\n          },\n        },\n        {\n          id: \"slotted-toggle\",\n          control: \"moz-toggle\",\n          l10nId: \"moz-box-toggle-action\",\n          controlAttrs: {\n            slot: \"actions\",\n          },\n        },\n        {\n          id: \"slotted-icon-button\",\n          control: \"moz-button\",\n          l10nId: \"moz-box-more-action\",\n          iconSrc: \"chrome://global/skin/icons/more.svg\",\n          controlAttrs: {\n            slot: \"actions\",\n          },\n        },\n      ],\n    },\n    {\n      id: \"link1\",\n      control: \"moz-box-link\",\n      l10nId: \"moz-box-link\",\n    },\n    {\n      id: \"button1\",\n      control: \"moz-box-button\",\n      l10nId: \"moz-box-button-1\",\n    },\n    {\n      id: \"item2\",\n      control: \"moz-box-item\",\n      l10nId: \"moz-box-item\",\n      options: [\n        {\n          id: \"slotted-button-start\",\n          control: \"moz-button\",\n          l10nId: \"moz-box-edit-action\",\n          iconSrc: \"chrome://global/skin/icons/edit-outline.svg\",\n          controlAttrs: {\n            type: \"ghost\",\n            slot: \"actions-start\",\n          },\n        },\n        {\n          id: \"slotted-icon-button-start\",\n          control: \"moz-button\",\n          l10nId: \"moz-box-more-action\",\n          iconSrc: \"chrome://global/skin/icons/more.svg\",\n          controlAttrs: {\n            slot: \"actions-start\",\n          },\n        },\n      ],\n    },\n    {\n      id: \"button2\",\n      control: \"moz-box-button\",\n      l10nId: \"moz-box-button-2\",\n    },\n    ...(hasFooter\n      ? [\n          {\n            id: \"footer\",\n            control: \"moz-box-button\",\n            l10nId: \"moz-box-button-footer\",\n            controlAttrs: { slot: \"footer \" },\n          },\n        ]\n      : []),\n  ],\n});\n\nconst DEFAULT_SETTING = {\n  value: 1,\n  on() {},\n  off() {},\n  userChange() {},\n  getControlConfig: c => c,\n  controllingExtensionInfo: {},\n  visible: true,\n};\n\nfunction getSetting() {\n  return {\n    value: true,\n    on() {},\n    off() {},\n    userChange() {},\n    visible: () => true,\n    getControlConfig: c => c,\n    controllingExtensionInfo: {},\n  };\n}\n\nconst Template = ({ type, hasHeader, hasFooter, scrollable, wrapped }) => html`\n  <style>\n    moz-box-group {\n      --box-group-max-height: ${scrollable ? \"250px\" : \"unset\"};\n    }\n\n    .delete {\n      margin-top: var(--space-medium);\n    }\n  </style>\n  ${wrapped\n    ? wrappedTemplate({ type, hasHeader, hasFooter })\n    : basicTemplate({ type, hasHeader, hasFooter, wrapped })}\n`;\n\nexport const Default = Template.bind({});\nDefault.args = {\n  type: \"default\",\n  hasHeader: false,\n  hasFooter: false,\n  scrollable: false,\n  wrapped: false,\n};\n\nexport const List = Template.bind({});\nList.args = {\n  ...Default.args,\n  type: \"list\",\n};\n\nexport const Reorderable = Template.bind({});\nReorderable.args = {\n  ...Default.args,\n  type: \"reorderable\",\n};\n\nexport const ListWithHeaderAndFooter = Template.bind({});\nListWithHeaderAndFooter.args = {\n  ...List.args,\n  hasHeader: true,\n  hasFooter: true,\n};\n\nexport const Scrollable = Template.bind({});\nScrollable.args = {\n  ...ListWithHeaderAndFooter.args,\n  scrollable: true,\n};\n\nexport const Wrapped = Template.bind({});\nWrapped.args = {\n  ...ListWithHeaderAndFooter.args,\n  wrapped: true,\n};\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nimport {\n  Directive,\n  noChange,\n  nothing,\n  directive,\n} from \"chrome://global/content/vendor/lit.all.mjs\";\n\nimport { MozLitElement } from \"chrome://global/content/lit-utils.mjs\";\n\n/** @import { AttributePart } from \"chrome://global/content/vendor/lit.all.mjs\" */\n\n/**\n * @typedef {object} SettingElementConfig\n * @property {string} [id] - The ID for the Setting, this should match the layout id\n * @property {string} [l10nId] - The Fluent l10n ID for the setting\n * @property {Record<string, string>} [l10nArgs] - An object containing l10n IDs and their values that will be translated with Fluent\n * @property {Record<string, any>} [controlAttrs] - An object of additional attributes to be set on the control. These can be used to further customize the control for example a message bar of the warning type, or what dialog a button should open\n * @property {string} [iconSrc] - A path to the icon for the control (if the control supports one)\n * @property {string} [slot] - The named slot for the control\n * @property {string} [supportPage] - The SUMO support page slug for the setting\n * @property {string} [subcategory] - The sub-category slug used for direct linking to a setting from SUMO\n */\n\n/**\n * A Lit directive that applies all properties of an object to a DOM element.\n *\n * This directive interprets keys in the provided props object as follows:\n * - Keys starting with `?` set or remove boolean attributes using `toggleAttribute`.\n * - Keys starting with `.` set properties directly on the element.\n * - Keys starting with `@` are currently not supported and will throw an error.\n * - All other keys are applied as regular attributes using `setAttribute`.\n *\n * It avoids reapplying values that have not changed, but does not currently\n * remove properties that were previously set and are no longer present in the new input.\n *\n * This directive is useful to \"spread\" an object of attributes/properties declaratively onto an\n * element in a Lit template.\n */\nclass SpreadDirective extends Directive {\n  /**\n   * A record of previously applied properties to avoid redundant updates.\n   *\n   * @type {Record<string, unknown>}\n   */\n  #prevProps = {};\n\n  /**\n   * Render nothing by default as all changes are made in update using DOM APIs\n   * on the element directly.\n   *\n   * @param {Record<string, unknown>} props The props to apply to this element.\n   */\n  // eslint-disable-next-line no-unused-vars\n  render(props) {\n    return nothing;\n  }\n\n  /**\n   * Apply props to the element using DOM APIs, updating only changed values.\n   *\n   * @param {AttributePart} part - The part of the template this directive is bound to.\n   * @param {[Record<string, unknown>]} propsArray - An array with a single object containing props to apply.\n   * @returns {typeof noChange} - Indicates to Lit that no re-render is needed.\n   */\n  update(part, [props]) {\n    // TODO: This doesn't clear any values that were set in previous calls if\n    // they are no longer present.\n    // It isn't entirely clear to me (mstriemer) what we should do if a prop is\n    // removed, or if the prop has changed from say ?foo to foo. By not\n    // implementing the auto-clearing hopefully the consumer will do something\n    // that fits their use case.\n\n    let el = part.element;\n\n    for (let [key, value] of Object.entries(props)) {\n      // Skip if the value hasn't changed since the last update.\n      if (value === this.#prevProps[key]) {\n        continue;\n      }\n\n      // Update the element based on the property key matching Lit's templates:\n      //   ?key -> el.toggleAttribute(key, value)\n      //   .key -> el.key = value\n      //   key -> el.setAttribute(key, value)\n      if (key.startsWith(\"?\")) {\n        el.toggleAttribute(key.slice(1), Boolean(value));\n      } else if (key.startsWith(\".\")) {\n        // @ts-ignore\n        el[key.slice(1)] = value;\n      } else if (key.startsWith(\"@\")) {\n        throw new Error(\n          `Event listeners are not yet supported with spread (${key})`\n        );\n      } else {\n        el.setAttribute(key, String(value));\n      }\n    }\n\n    // Save current props for comparison in the next update.\n    this.#prevProps = props;\n\n    return noChange;\n  }\n}\n\nexport const spread = directive(SpreadDirective);\n\nexport class SettingElement extends MozLitElement {\n  /**\n   * The default properties that the setting element accepts.\n   *\n   * @param {SettingElementConfig} config\n   */\n  getCommonPropertyMapping(config) {\n    return {\n      id: config.id,\n      \"data-l10n-id\": config.l10nId ? config.l10nId : undefined,\n      \"data-l10n-args\": config.l10nArgs\n        ? JSON.stringify(config.l10nArgs)\n        : undefined,\n      \".iconSrc\": config.iconSrc,\n      \"data-subcategory\": config.subcategory,\n      \".supportPage\":\n        config.supportPage != undefined ? config.supportPage : undefined,\n      slot: config.slot,\n      ...config.controlAttrs,\n    };\n  }\n}\n","import __chrome_styles_loader__mozboxgroupStyles from \"toolkit/content/widgets/moz-box-group/moz-box-group.css\";\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nimport { html, staticHtml, literal } from \"../vendor/lit.all.mjs\";\nimport { MozLitElement } from \"../lit-utils.mjs\";\n\nexport const GROUP_TYPES = {\n  list: \"list\",\n  reorderable: \"reorderable-list\",\n};\n\n/**\n * An element used to group combinations of moz-box-item, moz-box-link, and\n * moz-box-button elements and provide the expected styles.\n *\n * @tagname moz-box-group\n * @property {string} type\n *   The type of the group, either \"list\", \"reorderable-list\", or undefined.\n *   Note that \"reorderable-list\" only works with moz-box-item elements for now.\n * @slot default - Slot for rendering various moz-box-* elements.\n * @slot <index> - Slots used to assign moz-box-* elements to <li> elements when\n *   the group is type=\"list\".\n */\nexport default class MozBoxGroup extends MozLitElement {\n  #tabbable = true;\n\n  static properties = {\n    type: { type: String },\n    listItems: { type: Array, state: true },\n  };\n\n  static queries = {\n    reorderableList: \"moz-reorderable-list\",\n    headerSlot: \"slot[name='header']\",\n    footerSlot: \"slot[name='footer']\",\n  };\n\n  constructor() {\n    super();\n    this.listItems = [];\n    this.listMutationObserver = new MutationObserver(\n      this.updateItems.bind(this)\n    );\n  }\n\n  firstUpdated(changedProperties) {\n    super.firstUpdated(changedProperties);\n    this.listMutationObserver.observe(this, {\n      attributeFilter: [\"hidden\"],\n      subtree: true,\n      childList: true,\n    });\n    this.updateItems();\n  }\n\n  contentTemplate() {\n    if (this.type == GROUP_TYPES.reorderable) {\n      return html`<moz-reorderable-list\n        class=\"scroll-container\"\n        itemselector=\"moz-box-item\"\n        dragselector=\".handle\"\n        @reorder=${this.handleReorder}\n      >\n        ${this.slotTemplate()}\n      </moz-reorderable-list>`;\n    }\n    return this.slotTemplate();\n  }\n\n  slotTemplate() {\n    if (this.type == GROUP_TYPES.list || this.type == GROUP_TYPES.reorderable) {\n      let listTag =\n        this.type == GROUP_TYPES.reorderable ? literal`ol` : literal`ul`;\n      return staticHtml`<${listTag}\n          tabindex=\"-1\"\n          class=\"list scroll-container\"\n          aria-orientation=\"vertical\"\n          @keydown=${this.handleKeydown}\n          @focusin=${this.handleFocus}\n          @focusout=${this.handleBlur}\n        >\n          ${this.listItems.map((_, i) => {\n            return html`<li>\n              <slot name=${i}></slot>\n            </li> `;\n          })}\n        </${listTag}>\n        <slot hidden></slot>`;\n    }\n    return html`<div class=\"scroll-container\">\n      <slot></slot>\n    </div>`;\n  }\n\n  handleReorder(event) {\n    let { draggedElement, targetElement, position } = event.detail;\n    let parent = targetElement.parentNode;\n    let moveBefore = position === -1;\n\n    if (moveBefore) {\n      parent.insertBefore(draggedElement, targetElement);\n    } else {\n      parent.insertBefore(draggedElement, targetElement.nextElementSibling);\n    }\n\n    draggedElement.focus();\n    this.updateItems();\n  }\n\n  handleKeydown(event) {\n    if (\n      this.type == GROUP_TYPES.reorderable &&\n      event.originalTarget == event.target.handleEl\n    ) {\n      let detail = this.reorderableList.evaluateKeyDownEvent(event);\n      if (detail) {\n        event.stopPropagation();\n        this.handleReorder({ detail });\n        return;\n      }\n    }\n\n    let positionElement = event.target.closest(\"[position]\");\n    if (!positionElement) {\n      // If the user has clicked on the MozBoxGroup it may get keydown events\n      // even if there is no focused element within it. Then the event target\n      // will be the <ul> and we won't find an element with [position].\n      return;\n    }\n    let positionAttr = positionElement.getAttribute(\"position\");\n    let currentPosition = parseInt(positionAttr);\n\n    switch (event.key) {\n      case \"Down\":\n      case \"ArrowDown\": {\n        event.preventDefault();\n        let nextItem = this.listItems[currentPosition + 1];\n        nextItem?.focus(event);\n        break;\n      }\n      case \"Up\":\n      case \"ArrowUp\": {\n        event.preventDefault();\n        let prevItem = this.listItems[currentPosition - 1];\n        prevItem?.focus(event);\n        break;\n      }\n    }\n  }\n\n  handleFocus() {\n    if (this.#tabbable) {\n      this.#tabbable = false;\n      this.listItems.forEach(item => {\n        item.setAttribute(\"tabindex\", \"-1\");\n      });\n    }\n  }\n\n  handleBlur() {\n    if (!this.#tabbable) {\n      this.#tabbable = true;\n      this.listItems.forEach(item => {\n        item.removeAttribute(\"tabindex\");\n      });\n    }\n  }\n\n  updateItems() {\n    this.listItems = [...this.children].filter(\n      child =>\n        child.slot !== \"header\" && child.slot !== \"footer\" && !child.hidden\n    );\n  }\n\n  render() {\n    return html`\n      <link\n        rel=\"stylesheet\"\n        href=\"${__chrome_styles_loader__mozboxgroupStyles}\"\n      />\n      <slot name=\"header\"></slot>\n      ${this.contentTemplate()}\n      <slot name=\"footer\"></slot>\n    `;\n  }\n\n  updated(changedProperties) {\n    let headerNode = this.headerSlot.assignedNodes()[0];\n    let footerNode = this.footerSlot.assignedNodes().at(-1);\n    headerNode?.classList.add(\"first\");\n    footerNode?.classList.add(\"last\");\n\n    if (changedProperties.has(\"listItems\") && this.listItems.length) {\n      this.listItems.forEach((item, i) => {\n        if (\n          this.type == GROUP_TYPES.list ||\n          this.type == GROUP_TYPES.reorderable\n        ) {\n          item.slot = i;\n          item.setAttribute(\"position\", i);\n        }\n        item.classList.toggle(\"first\", i == 0 && !headerNode);\n        item.classList.toggle(\n          \"last\",\n          i == this.listItems.length - 1 && !footerNode\n        );\n      });\n    }\n\n    if (\n      changedProperties.has(\"type\") &&\n      (this.type == GROUP_TYPES.list || this.type == GROUP_TYPES.reorderable)\n    ) {\n      this.updateItems();\n    }\n  }\n}\ncustomElements.define(\"moz-box-group\", MozBoxGroup);\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nimport {\n  createRef,\n  html,\n  ifDefined,\n  literal,\n  ref,\n  staticHtml,\n  unsafeStatic,\n} from \"chrome://global/content/vendor/lit.all.mjs\";\nimport {\n  SettingElement,\n  spread,\n} from \"chrome://browser/content/preferences/widgets/setting-element.mjs\";\nimport MozInputFolder from \"chrome://global/content/elements/moz-input-folder.mjs\";\n\n/** @import { LitElement, Ref, TemplateResult } from \"chrome://global/content/vendor/lit.all.mjs\" */\n/** @import { SettingElementConfig } from \"chrome://browser/content/preferences/widgets/setting-element.mjs\" */\n/** @import { Setting } from \"chrome://global/content/preferences/Setting.mjs\" */\n\n/**\n * @typedef {object} SettingNestedConfig\n * @property {SettingControlConfig[]} [items] Additional nested SettingControls to render.\n * @property {SettingOptionConfig[]} [options]\n * Additional nested plain elements to render (may have SettingControls nested within them, though).\n */\n\n/**\n * @typedef {object} SettingOptionConfigExtensions\n * @property {string} [control]\n * The element tag to render, default assumed based on parent control.\n * @property {any} [value] A value to set on the option.\n */\n\n/**\n * @typedef {object} SettingControlConfigExtensions\n * @property {string} id\n * The ID for the Setting, also set in the DOM unless overridden with controlAttrs.id\n * @property {string} [control] The element to render, default to \"moz-checkbox\".\n * @property {string} [controllingExtensionInfo]\n * ExtensionSettingStore id for checking if a setting is controlled by an extension.\n */\n\n/**\n * @typedef {SettingOptionConfigExtensions & SettingElementConfig & SettingNestedConfig} SettingOptionConfig\n * @typedef {SettingControlConfigExtensions & SettingElementConfig & SettingNestedConfig} SettingControlConfig\n * @typedef {{ control: SettingControl } & HTMLElement} SettingControlChild\n */\n\n/**\n * @template T=Event\n * @typedef {T & { target: SettingControlChild }} SettingControlEvent\n * SettingControlEvent simplifies the types in this file, but causes issues when\n * doing more involved work when used in Setting.mjs. When casting the\n * `event.target` to a more specific type like MozButton (or even\n * HTMLButtonElement) it gets flagged as being too different from SettingControlChild.\n */\n\n/**\n * Mapping of parent control tag names to the literal tag name for their\n * expected children. eg. \"moz-radio-group\"->literal`moz-radio`.\n */\nconst KNOWN_OPTIONS = new Map([\n  [\"moz-radio-group\", literal`moz-radio`],\n  [\"moz-select\", literal`moz-option`],\n  [\"moz-visual-picker\", literal`moz-visual-picker-item`],\n]);\n\n/**\n * Mapping of parent control tag names to the expected slot for their children.\n * If there's no entry here for a control then it's expected that its children\n * should go in the default slot.\n *\n * @type Map<string, string>\n */\nconst ITEM_SLOT_BY_PARENT = new Map([\n  [\"moz-checkbox\", \"nested\"],\n  [\"moz-input-text\", \"nested\"],\n  [\"moz-input-search\", \"nested\"],\n  [\"moz-input-folder\", \"nested\"],\n  [\"moz-input-password\", \"nested\"],\n  [\"moz-radio\", \"nested\"],\n  [\"moz-radio-group\", \"nested\"],\n  // NOTE: moz-select does not support the nested slot.\n  [\"moz-toggle\", \"nested\"],\n]);\n\nexport class SettingNotDefinedError extends Error {\n  /** @param {string} settingId */\n  constructor(settingId) {\n    super(\n      `No Setting with id \"${settingId}\". Did you register it with Preferences.addSetting()?`\n    );\n    this.name = \"SettingNotDefinedError\";\n    this.settingId = settingId;\n  }\n}\n\nexport class SettingControl extends SettingElement {\n  static SettingNotDefinedError = SettingNotDefinedError;\n  static properties = {\n    setting: { type: Object },\n    config: { type: Object },\n    value: {},\n    parentDisabled: { type: Boolean },\n    tabIndex: { type: Number, reflect: true },\n    showEnableExtensionMessage: { type: Boolean, state: true },\n    isDisablingExtension: { type: Boolean, state: true },\n  };\n\n  /**\n   * @type {Setting | undefined}\n   */\n  #lastSetting;\n\n  constructor() {\n    super();\n    /** @type {Ref<LitElement>} */\n    this.controlRef = createRef();\n\n    /**\n     * @type {Preferences['getSetting'] | undefined}\n     */\n    this.getSetting = undefined;\n\n    /**\n     * @type {Setting | undefined}\n     */\n    this.setting = undefined;\n\n    /**\n     * @type {SettingControlConfig | undefined}\n     */\n    this.config = undefined;\n\n    /**\n     * @type {boolean | undefined}\n     */\n    this.parentDisabled = undefined;\n\n    /**\n     * @type {boolean}\n     */\n    this.showEnableExtensionMessage = false;\n\n    /**\n     * @type {boolean}\n     */\n    this.isDisablingExtension = false;\n  }\n\n  createRenderRoot() {\n    return this;\n  }\n\n  focus() {\n    this.controlEl.focus();\n  }\n\n  get controlEl() {\n    return this.controlRef.value;\n  }\n\n  async getUpdateComplete() {\n    let result = await super.getUpdateComplete();\n    await this.controlEl?.updateComplete;\n    return result;\n  }\n\n  onSettingChange = () => {\n    this.setValue();\n    this.requestUpdate();\n  };\n\n  /**\n   * @type {SettingElement['willUpdate']}\n   */\n  willUpdate(changedProperties) {\n    if (changedProperties.has(\"setting\")) {\n      if (this.#lastSetting) {\n        this.#lastSetting.off(\"change\", this.onSettingChange);\n      }\n      this.#lastSetting = this.setting;\n      this.setValue();\n      this.setting.on(\"change\", this.onSettingChange);\n    }\n    if (!this.setting) {\n      throw new SettingNotDefinedError(this.config.id);\n    }\n    let prevHidden = this.hidden;\n    this.hidden = !this.setting.visible;\n    if (prevHidden != this.hidden) {\n      this.dispatchEvent(new Event(\"visibility-change\", { bubbles: true }));\n    }\n  }\n\n  updated() {\n    const control = this.controlRef?.value;\n    if (!control) {\n      return;\n    }\n\n    // Set the value based on the control's API.\n    if (\"checked\" in control) {\n      control.checked = this.value;\n    } else if (\"pressed\" in control) {\n      control.pressed = this.value;\n    } else if (\"value\" in control) {\n      control.value = this.value;\n    }\n\n    control.requestUpdate();\n  }\n\n  /**\n   * The default properties that controls and options accept.\n   * Note: for the disabled property, a setting can either be locked,\n   * or controlled by an extension but not both.\n   *\n   * @override\n   * @param {SettingElementConfig} config\n   * @returns {ReturnType<SettingElement['getCommonPropertyMapping']>}\n   */\n  getCommonPropertyMapping(config) {\n    return {\n      ...super.getCommonPropertyMapping(config),\n      \".setting\": this.setting,\n      \".control\": this,\n    };\n  }\n\n  /**\n   * The default properties for an option.\n   *\n   * @param {SettingOptionConfig} config\n   */\n  getOptionPropertyMapping(config) {\n    const props = this.getCommonPropertyMapping(config);\n    props[\".value\"] = config.value;\n    props[\".disabled\"] = config.disabled;\n    props[\".hidden\"] = config.hidden;\n    return props;\n  }\n\n  /**\n   * The default properties for this control.\n   *\n   * @param {SettingControlConfig} config\n   */\n  getControlPropertyMapping(config) {\n    const props = this.getCommonPropertyMapping(config);\n    props[\".parentDisabled\"] = this.parentDisabled;\n    props[\"?disabled\"] =\n      this.setting.disabled ||\n      this.setting.locked ||\n      this.isControlledByExtension();\n\n    return props;\n  }\n\n  getValue() {\n    return this.setting.value;\n  }\n\n  setValue = () => {\n    this.value = this.setting.value;\n  };\n\n  /**\n   * @param {HTMLElement} el\n   * @returns {any}\n   */\n  controlValue(el) {\n    let Cls = el.constructor;\n    if (\n      \"activatedProperty\" in Cls &&\n      Cls.activatedProperty &&\n      el.localName != \"moz-radio\"\n    ) {\n      return el[/** @type {keyof typeof el} */ (Cls.activatedProperty)];\n    }\n    if (el instanceof MozInputFolder) {\n      return el.folder;\n    }\n    return \"value\" in el ? el.value : null;\n  }\n\n  /**\n   * Called by our parent when our input changed.\n   *\n   * @param {SettingControlChild} el\n   */\n  onChange(el) {\n    this.setting.userChange(this.controlValue(el));\n  }\n\n  /**\n   * Called by our parent when our input is clicked.\n   *\n   * @param {MouseEvent} event\n   */\n  onClick(event) {\n    this.setting.userClick(event);\n  }\n\n  async disableExtension() {\n    this.isDisablingExtension = true;\n    this.showEnableExtensionMessage = true;\n    await this.setting.disableControllingExtension();\n    this.isDisablingExtension = false;\n  }\n\n  isControlledByExtension() {\n    return (\n      this.setting.controllingExtensionInfo?.id &&\n      this.setting.controllingExtensionInfo?.name\n    );\n  }\n\n  handleEnableExtensionDismiss() {\n    this.showEnableExtensionMessage = false;\n  }\n\n  /**\n   * @param {MouseEvent} event\n   */\n  navigateToAddons(event) {\n    let link = /** @type {HTMLAnchorElement} */ (event.target);\n    if (link.matches(\"a[data-l10n-name='addons-link']\")) {\n      event.preventDefault();\n      // @ts-ignore\n      let mainWindow = window.browsingContext.topChromeWindow;\n      mainWindow.BrowserAddonUI.openAddonsMgr(\"addons://list/extension\");\n    }\n  }\n\n  get extensionName() {\n    return this.setting.controllingExtensionInfo.name;\n  }\n\n  get extensionMessageId() {\n    return this.setting.controllingExtensionInfo.l10nId;\n  }\n\n  /**\n   * Prepare nested item config and settings.\n   *\n   * @param {SettingControlConfig | SettingOptionConfig} config\n   * @returns {TemplateResult[]}\n   */\n  itemsTemplate(config) {\n    if (!config.items) {\n      return [];\n    }\n\n    const itemArgs = config.items.map(i => ({\n      config: i,\n      setting: this.getSetting(i.id),\n    }));\n    let control = config.control || \"moz-checkbox\";\n    return itemArgs.map(\n      item =>\n        html`<setting-control\n          .config=${item.config}\n          .setting=${item.setting}\n          .getSetting=${this.getSetting}\n          slot=${ifDefined(\n            item.config.slot || ITEM_SLOT_BY_PARENT.get(control)\n          )}\n        ></setting-control>`\n    );\n  }\n\n  /**\n   * Prepares any children (and any of its children's children) that this element may need.\n   *\n   * @param {SettingOptionConfig} config\n   * @returns {TemplateResult[]}\n   */\n  optionsTemplate(config) {\n    if (!config.options) {\n      return [];\n    }\n    let control = config.control || \"moz-checkbox\";\n    return config.options.map(opt => {\n      let optionTag = opt.control\n        ? unsafeStatic(opt.control)\n        : KNOWN_OPTIONS.get(control);\n      let spreadValues = spread(this.getOptionPropertyMapping(opt));\n      let children =\n        \"items\" in opt ? this.itemsTemplate(opt) : this.optionsTemplate(opt);\n      if (opt.control == \"a\" && opt.controlAttrs?.is == \"moz-support-link\") {\n        // The `is` attribute must be set when the element is first added to the\n        // DOM. We need to mark that up manually, since `spread()` uses\n        // `el.setAttribute()` to set attributes it receives.\n        return html`<a is=\"moz-support-link\" ${spreadValues}>${children}</a>`;\n      }\n      return staticHtml`<${optionTag} ${spreadValues}>${children}</${optionTag}>`;\n    });\n  }\n\n  get extensionSupportPage() {\n    return this.setting.controllingExtensionInfo.supportPage;\n  }\n\n  render() {\n    // Allow the Setting to override the static config if necessary.\n    this.config = this.setting.getControlConfig(this.config);\n    let { config } = this;\n    let control = config.control || \"moz-checkbox\";\n\n    let nestedSettings =\n      \"items\" in config\n        ? this.itemsTemplate(config)\n        : this.optionsTemplate(config);\n\n    // Get the properties for this element: id, fluent, disabled, etc.\n    // These will be applied to the control using the spread directive.\n    let controlProps = this.getControlPropertyMapping(config);\n\n    let tag = unsafeStatic(control);\n    let messageBar;\n\n    // NOTE: the showEnableMessage message bar should ONLY appear when\n    // there are no extensions controlling the setting.\n    if (this.isControlledByExtension()) {\n      let args = { name: this.extensionName };\n      let supportPage = this.extensionSupportPage;\n      messageBar = html`<moz-message-bar\n        class=\"extension-controlled-message-bar\"\n        .messageL10nId=${this.extensionMessageId}\n        .messageL10nArgs=${args}\n      >\n        ${supportPage\n          ? html`<a\n              is=\"moz-support-link\"\n              slot=\"support-link\"\n              support-page=${supportPage}\n            ></a>`\n          : \"\"}\n        <moz-button\n          slot=\"actions\"\n          @click=${this.disableExtension}\n          ?disabled=${this.isDisablingExtension}\n          data-l10n-id=\"disable-extension\"\n        ></moz-button>\n      </moz-message-bar>`;\n    } else if (this.showEnableExtensionMessage) {\n      messageBar = html`<moz-message-bar\n        class=\"reenable-extensions-message-bar\"\n        dismissable=\"\"\n        @message-bar:user-dismissed=${this.handleEnableExtensionDismiss}\n      >\n        <span\n          @click=${this.navigateToAddons}\n          slot=\"message\"\n          data-l10n-id=\"extension-controlled-enable-2\"\n        >\n          <a data-l10n-name=\"addons-link\" href=\"#\"></a>\n        </span>\n      </moz-message-bar>`;\n    }\n    return staticHtml`\n    ${messageBar}\n    <${tag}\n      ${spread(controlProps)}\n      ${ref(this.controlRef)}\n      tabindex=${ifDefined(this.tabIndex)}\n    >${nestedSettings}</${tag}>`;\n  }\n}\ncustomElements.define(\"setting-control\", SettingControl);\n","import __chrome_styles_loader__mozinputtextStyles from \"toolkit/content/widgets/moz-input-text/moz-input-text.css\";\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nimport { html, ifDefined } from \"../vendor/lit.all.mjs\";\nimport { MozBaseInputElement } from \"../lit-utils.mjs\";\n\n/**\n * A text input custom element.\n *\n * @tagname moz-input-text\n * @property {string} label - The text of the label element\n * @property {string} name - The name of the input control\n * @property {string} value - The value of the input control\n * @property {boolean} disabled - The disabled state of the input control\n * @property {boolean} readonly - The readonly state of the input control\n * @property {string} iconSrc - The src for an optional icon\n * @property {string} description - The text for the description element that helps describe the input control\n * @property {string} supportPage - Name of the SUMO support page to link to.\n * @property {string} placeholder - Text to display when the input has no value.\n * @property {string} ariaLabel - The aria-label text when there is no visible label.\n * @property {string} ariaDescription - The aria-description text when there is no visible description.\n */\nexport default class MozInputText extends MozBaseInputElement {\n  static properties = {\n    placeholder: { type: String, fluent: true },\n    readonly: { type: Boolean, reflect: true },\n  };\n  static inputLayout = \"block\";\n\n  constructor() {\n    super();\n    this.value = \"\";\n    this.readonly = false;\n  }\n\n  inputStylesTemplate() {\n    return html`<link\n      rel=\"stylesheet\"\n      href=\"${__chrome_styles_loader__mozinputtextStyles}\"\n    />`;\n  }\n\n  handleInput(e) {\n    this.value = e.target.value;\n  }\n\n  inputTemplate(options = {}) {\n    let { type = \"text\", classes, styles, inputValue } = options;\n\n    return html`\n      <input\n        id=\"input\"\n        type=${type}\n        class=${ifDefined(classes)}\n        style=${ifDefined(styles)}\n        name=${this.name}\n        .value=${inputValue || this.value}\n        ?disabled=${this.disabled || this.parentDisabled}\n        ?readonly=${this.readonly}\n        accesskey=${ifDefined(this.accessKey)}\n        placeholder=${ifDefined(this.placeholder)}\n        aria-label=${ifDefined(this.ariaLabel ?? undefined)}\n        aria-describedby=\"description\"\n        aria-description=${ifDefined(\n          this.hasDescription ? undefined : this.ariaDescription\n        )}\n        @input=${this.handleInput}\n        @change=${this.redispatchEvent}\n      />\n    `;\n  }\n}\ncustomElements.define(\"moz-input-text\", MozInputText);\n"],"names":[],"sourceRoot":""}