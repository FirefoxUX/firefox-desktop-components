{"version":3,"file":"3321.235a7fed.iframe.bundle.js","mappings":";;;;;;AAAA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack:///../../../toolkit/content/widgets/named-deck.js"],"sourcesContent":["/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n\"use strict\";\n\n// This is loaded into chrome windows with the subscript loader. Wrap in\n// a block to prevent accidentally leaking globals onto `window`.\n{\n  /**\n   * This element is for use with the <named-deck> element. Set the target\n   * <named-deck>'s ID in the \"deck\" attribute and the button's selected state\n   * will reflect the deck's state. When the button is clicked, it will set the\n   * view in the <named-deck> to the button's \"name\" attribute.\n   *\n   * The \"tab\" role will be added unless a different role is provided. Wrapping\n   * a set of these buttons in a <button-group> element will add the key handling\n   * for a tablist.\n   *\n   * NOTE: This does not observe changes to the \"deck\" or \"name\" attributes, so\n   * changing them likely won't work properly.\n   *\n   * <button is=\"named-deck-button\" deck=\"pet-deck\" name=\"dogs\">Dogs</button>\n   * <named-deck id=\"pet-deck\">\n   *   <p name=\"cats\">I like cats.</p>\n   *   <p name=\"dogs\">I like dogs.</p>\n   * </named-deck>\n   *\n   * let btn = document.querySelector('button[name=\"dogs\"]');\n   * let deck = document.querySelector(\"named-deck\");\n   * deck.selectedViewName == \"cats\";\n   * btn.selected == false; // Selected was pulled from the related deck.\n   * btn.click();\n   * deck.selectedViewName == \"dogs\";\n   * btn.selected == true; // Selected updated when view changed.\n   */\n  class NamedDeckButton extends HTMLButtonElement {\n    connectedCallback() {\n      this.id = `${this.deckId}-button-${this.name}`;\n      if (!this.hasAttribute(\"role\")) {\n        this.setAttribute(\"role\", \"tab\");\n      }\n      this.setSelectedFromDeck();\n      this.addEventListener(\"click\", this);\n      this.getRootNode().addEventListener(\"view-changed\", this, {\n        capture: true,\n      });\n    }\n\n    disconnectedCallback() {\n      this.removeEventListener(\"click\", this);\n      this.getRootNode().removeEventListener(\"view-changed\", this, {\n        capture: true,\n      });\n    }\n\n    attributeChangedCallback(name, oldVal, newVal) {\n      if (name == \"selected\") {\n        this.selected = newVal;\n      }\n    }\n\n    get deckId() {\n      return this.getAttribute(\"deck\");\n    }\n\n    set deckId(val) {\n      this.setAttribute(\"deck\", val);\n    }\n\n    get deck() {\n      return this.getRootNode().querySelector(`#${this.deckId}`);\n    }\n\n    handleEvent(e) {\n      if (e.type == \"view-changed\" && e.target.id == this.deckId) {\n        this.setSelectedFromDeck();\n      } else if (e.type == \"click\") {\n        let { deck } = this;\n        if (deck) {\n          deck.selectedViewName = this.name;\n        }\n      }\n    }\n\n    get name() {\n      return this.getAttribute(\"name\");\n    }\n\n    get selected() {\n      return this.hasAttribute(\"selected\");\n    }\n\n    set selected(val) {\n      if (this.selected != val) {\n        this.toggleAttribute(\"selected\", val);\n      }\n      this.setAttribute(\"aria-selected\", !!val);\n    }\n\n    setSelectedFromDeck() {\n      let { deck } = this;\n      this.selected = deck && deck.selectedViewName == this.name;\n      if (this.selected) {\n        this.dispatchEvent(\n          new CustomEvent(\"button-group:selected\", { bubbles: true })\n        );\n      }\n    }\n  }\n  customElements.define(\"named-deck-button\", NamedDeckButton, {\n    extends: \"button\",\n  });\n\n  class ButtonGroup extends HTMLElement {\n    static get observedAttributes() {\n      return [\"orientation\"];\n    }\n\n    connectedCallback() {\n      this.setAttribute(\"role\", \"tablist\");\n\n      if (!this.observer) {\n        this.observer = new MutationObserver(changes => {\n          for (let change of changes) {\n            this.setChildAttributes(change.addedNodes);\n            for (let node of change.removedNodes) {\n              if (this.activeChild == node) {\n                // Ensure there's still an active child.\n                this.activeChild = this.firstElementChild;\n              }\n            }\n          }\n        });\n      }\n      this.observer.observe(this, { childList: true });\n\n      // Set the role and tabindex for the current children.\n      this.setChildAttributes(this.children);\n\n      // Try assigning the active child again, this will run through the checks\n      // to ensure it's still valid.\n      this.activeChild = this._activeChild;\n\n      this.addEventListener(\"button-group:selected\", this);\n      this.addEventListener(\"keydown\", this);\n      this.addEventListener(\"mousedown\", this);\n      this.getRootNode().addEventListener(\"keypress\", this);\n    }\n\n    disconnectedCallback() {\n      this.observer.disconnect();\n      this.removeEventListener(\"button-group:selected\", this);\n      this.removeEventListener(\"keydown\", this);\n      this.removeEventListener(\"mousedown\", this);\n      this.getRootNode().removeEventListener(\"keypress\", this);\n    }\n\n    attributeChangedCallback(name) {\n      if (name == \"orientation\") {\n        if (this.isVertical) {\n          this.setAttribute(\"aria-orientation\", this.orientation);\n        } else {\n          this.removeAttribute(\"aria-orientation\");\n        }\n      }\n    }\n\n    setChildAttributes(nodes) {\n      for (let node of nodes) {\n        if (node.nodeType == Node.ELEMENT_NODE && node != this.activeChild) {\n          node.setAttribute(\"tabindex\", \"-1\");\n        }\n      }\n    }\n\n    // The activeChild is the child that can be focused with tab.\n    get activeChild() {\n      return this._activeChild;\n    }\n\n    set activeChild(node) {\n      let prevActiveChild = this._activeChild;\n      let newActiveChild;\n\n      if (node && this.contains(node)) {\n        newActiveChild = node;\n      } else {\n        newActiveChild = this.firstElementChild;\n      }\n\n      this._activeChild = newActiveChild;\n\n      if (newActiveChild) {\n        newActiveChild.setAttribute(\"tabindex\", \"0\");\n      }\n\n      if (prevActiveChild && prevActiveChild != newActiveChild) {\n        prevActiveChild.setAttribute(\"tabindex\", \"-1\");\n      }\n    }\n\n    get isVertical() {\n      return this.orientation == \"vertical\";\n    }\n\n    get orientation() {\n      return this.getAttribute(\"orientation\") == \"vertical\"\n        ? \"vertical\"\n        : \"horizontal\";\n    }\n\n    set orientation(val) {\n      if (val == \"vertical\") {\n        this.setAttribute(\"orientation\", val);\n      } else {\n        this.removeAttribute(\"orientation\");\n      }\n    }\n\n    _navigationKeys() {\n      if (this.isVertical) {\n        return {\n          previousKey: \"ArrowUp\",\n          nextKey: \"ArrowDown\",\n        };\n      }\n      if (document.dir == \"rtl\") {\n        return {\n          previousKey: \"ArrowRight\",\n          nextKey: \"ArrowLeft\",\n        };\n      }\n      return {\n        previousKey: \"ArrowLeft\",\n        nextKey: \"ArrowRight\",\n      };\n    }\n\n    handleEvent(e) {\n      let { previousKey, nextKey } = this._navigationKeys();\n      if (e.type == \"keydown\" && (e.key == previousKey || e.key == nextKey)) {\n        this.setAttribute(\"last-input-type\", \"keyboard\");\n        e.preventDefault();\n        let oldFocus = this.activeChild;\n        this.walker.currentNode = oldFocus;\n        let newFocus;\n        if (e.key == previousKey) {\n          newFocus = this.walker.previousNode();\n        } else {\n          newFocus = this.walker.nextNode();\n        }\n        if (newFocus) {\n          this.activeChild = newFocus;\n          this.dispatchEvent(new CustomEvent(\"button-group:key-selected\"));\n        }\n      } else if (e.type == \"button-group:selected\") {\n        this.activeChild = e.target;\n      } else if (e.type == \"mousedown\") {\n        this.setAttribute(\"last-input-type\", \"mouse\");\n      } else if (e.type == \"keypress\" && e.key == \"Tab\") {\n        this.setAttribute(\"last-input-type\", \"keyboard\");\n      }\n    }\n\n    get walker() {\n      if (!this._walker) {\n        this._walker = document.createTreeWalker(\n          this,\n          NodeFilter.SHOW_ELEMENT,\n          {\n            acceptNode: node => {\n              if (node.hidden || node.disabled) {\n                return NodeFilter.FILTER_REJECT;\n              }\n              node.focus();\n              return this.getRootNode().activeElement == node\n                ? NodeFilter.FILTER_ACCEPT\n                : NodeFilter.FILTER_REJECT;\n            },\n          }\n        );\n      }\n      return this._walker;\n    }\n  }\n  customElements.define(\"button-group\", ButtonGroup);\n\n  /**\n   * A deck that is indexed by the \"name\" attribute of its children. The\n   * <named-deck-button> element is a companion element that can update its state\n   * and change the view of a <named-deck>.\n   *\n   * When the deck is connected it will set the first child as the selected view\n   * if a view is not already selected.\n   *\n   * The deck is implemented using a named slot. Setting a slot directly on a\n   * child element of the deck is not supported.\n   *\n   * You can get or set the selected view by name with the `selectedViewName`\n   * property or by setting the \"selected-view\" attribute.\n   *\n   * <named-deck>\n   *   <section name=\"cats\">Some info about cats.</section>\n   *   <section name=\"dogs\">Some dog stuff.</section>\n   * </named-deck>\n   *\n   * let deck = document.querySelector(\"named-deck\");\n   * deck.selectedViewName == \"cats\"; // Cat info is shown.\n   * deck.selectedViewName = \"dogs\";\n   * deck.selectedViewName == \"dogs\"; // Dog stuff is shown.\n   * deck.setAttribute(\"selected-view\", \"cats\");\n   * deck.selectedViewName == \"cats\"; // Cat info is shown.\n   *\n   * Add the is-tabbed attribute to <named-deck> if you want\n   * each of its children to have a tabpanel role and aria-labelledby\n   * referencing the NamedDeckButton component.\n   */\n  class NamedDeck extends HTMLElement {\n    static get observedAttributes() {\n      return [\"selected-view\"];\n    }\n\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n\n      // Create a slot for the visible content.\n      let selectedSlot = document.createElement(\"slot\");\n      selectedSlot.setAttribute(\"name\", \"selected\");\n      this.shadowRoot.appendChild(selectedSlot);\n\n      this.observer = new MutationObserver(() => {\n        this._setSelectedViewAttributes();\n      });\n    }\n\n    connectedCallback() {\n      if (this.selectedViewName) {\n        // Make sure the selected view is shown.\n        this._setSelectedViewAttributes();\n      } else {\n        // If there's no selected view, default to the first.\n        let firstView = this.firstElementChild;\n        if (firstView) {\n          // This will trigger showing the first view.\n          this.selectedViewName = firstView.getAttribute(\"name\");\n        }\n      }\n      this.observer.observe(this, { childList: true });\n    }\n\n    disconnectedCallback() {\n      this.observer.disconnect();\n    }\n\n    attributeChangedCallback(attr, oldVal, newVal) {\n      if (attr == \"selected-view\" && oldVal != newVal) {\n        // Update the slot attribute on the views.\n        this._setSelectedViewAttributes();\n\n        // Notify that the selected view changed.\n        this.dispatchEvent(new CustomEvent(\"view-changed\"));\n      }\n    }\n\n    get selectedViewName() {\n      return this.getAttribute(\"selected-view\");\n    }\n\n    set selectedViewName(name) {\n      this.setAttribute(\"selected-view\", name);\n    }\n\n    /**\n     * Set the slot attribute on all of the views to ensure only the selected view\n     * is shown.\n     */\n    _setSelectedViewAttributes() {\n      let { selectedViewName } = this;\n      for (let view of this.children) {\n        let name = view.getAttribute(\"name\");\n\n        if (this.hasAttribute(\"is-tabbed\")) {\n          view.setAttribute(\"aria-labelledby\", `${this.id}-button-${name}`);\n          view.setAttribute(\"role\", \"tabpanel\");\n        }\n\n        if (name === selectedViewName) {\n          view.slot = \"selected\";\n        } else {\n          view.slot = \"\";\n        }\n      }\n    }\n  }\n  customElements.define(\"named-deck\", NamedDeck);\n}\n"],"names":[],"sourceRoot":""}