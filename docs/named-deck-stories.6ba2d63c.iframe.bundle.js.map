{"version":3,"file":"named-deck-stories.6ba2d63c.iframe.bundle.js","mappings":";;;;;;AAAA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC7YA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAYA;AACA;AAEA;AAAA;AAAA;AA4CA;AAAA;AAAA;AAkEA;AAAA;AAAA;AACA;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA","sources":["webpack:///../../../toolkit/content/widgets/named-deck.js","webpack:///./stories/named-deck.stories.mjs"],"sourcesContent":["/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n\"use strict\";\n\n// This is loaded into chrome windows with the subscript loader. Wrap in\n// a block to prevent accidentally leaking globals onto `window`.\n{\n  /**\n   * This element is for use with the <named-deck> element. Set the target\n   * <named-deck>'s ID in the \"deck\" attribute and the button's selected state\n   * will reflect the deck's state. When the button is clicked, it will set the\n   * view in the <named-deck> to the button's \"name\" attribute.\n   *\n   * The \"tab\" role will be added unless a different role is provided. Wrapping\n   * a set of these buttons in a <button-group> element will add the key handling\n   * for a tablist.\n   *\n   * NOTE: This does not observe changes to the \"deck\" or \"name\" attributes, so\n   * changing them likely won't work properly.\n   *\n   * <button is=\"named-deck-button\" deck=\"pet-deck\" name=\"dogs\">Dogs</button>\n   * <named-deck id=\"pet-deck\">\n   *   <p name=\"cats\">I like cats.</p>\n   *   <p name=\"dogs\">I like dogs.</p>\n   * </named-deck>\n   *\n   * let btn = document.querySelector('button[name=\"dogs\"]');\n   * let deck = document.querySelector(\"named-deck\");\n   * deck.selectedViewName == \"cats\";\n   * btn.selected == false; // Selected was pulled from the related deck.\n   * btn.click();\n   * deck.selectedViewName == \"dogs\";\n   * btn.selected == true; // Selected updated when view changed.\n   */\n  class NamedDeckButton extends HTMLButtonElement {\n    connectedCallback() {\n      this.id = `${this.deckId}-button-${this.name}`;\n      if (!this.hasAttribute(\"role\")) {\n        this.setAttribute(\"role\", \"tab\");\n      }\n      this.setSelectedFromDeck();\n      this.addEventListener(\"click\", this);\n      this.getRootNode().addEventListener(\"view-changed\", this, {\n        capture: true,\n      });\n    }\n\n    disconnectedCallback() {\n      this.removeEventListener(\"click\", this);\n      this.getRootNode().removeEventListener(\"view-changed\", this, {\n        capture: true,\n      });\n    }\n\n    attributeChangedCallback(name, oldVal, newVal) {\n      if (name == \"selected\") {\n        this.selected = newVal;\n      }\n    }\n\n    get deckId() {\n      return this.getAttribute(\"deck\");\n    }\n\n    set deckId(val) {\n      this.setAttribute(\"deck\", val);\n    }\n\n    get deck() {\n      return this.getRootNode().querySelector(`#${this.deckId}`);\n    }\n\n    handleEvent(e) {\n      if (e.type == \"view-changed\" && e.target.id == this.deckId) {\n        this.setSelectedFromDeck();\n      } else if (e.type == \"click\") {\n        let { deck } = this;\n        if (deck) {\n          deck.selectedViewName = this.name;\n        }\n      }\n    }\n\n    get name() {\n      return this.getAttribute(\"name\");\n    }\n\n    get selected() {\n      return this.hasAttribute(\"selected\");\n    }\n\n    set selected(val) {\n      if (this.selected != val) {\n        this.toggleAttribute(\"selected\", val);\n      }\n      this.setAttribute(\"aria-selected\", !!val);\n    }\n\n    setSelectedFromDeck() {\n      let { deck } = this;\n      this.selected = deck && deck.selectedViewName == this.name;\n      if (this.selected) {\n        this.dispatchEvent(\n          new CustomEvent(\"button-group:selected\", { bubbles: true })\n        );\n      }\n    }\n  }\n  customElements.define(\"named-deck-button\", NamedDeckButton, {\n    extends: \"button\",\n  });\n\n  class ButtonGroup extends HTMLElement {\n    static get observedAttributes() {\n      return [\"orientation\"];\n    }\n\n    connectedCallback() {\n      this.setAttribute(\"role\", \"tablist\");\n\n      if (!this.observer) {\n        this.observer = new MutationObserver(changes => {\n          for (let change of changes) {\n            this.setChildAttributes(change.addedNodes);\n            for (let node of change.removedNodes) {\n              if (this.activeChild == node) {\n                // Ensure there's still an active child.\n                this.activeChild = this.firstElementChild;\n              }\n            }\n          }\n        });\n      }\n      this.observer.observe(this, { childList: true });\n\n      // Set the role and tabindex for the current children.\n      this.setChildAttributes(this.children);\n\n      // Try assigning the active child again, this will run through the checks\n      // to ensure it's still valid.\n      this.activeChild = this._activeChild;\n\n      this.addEventListener(\"button-group:selected\", this);\n      this.addEventListener(\"keydown\", this);\n      this.addEventListener(\"mousedown\", this);\n      this.getRootNode().addEventListener(\"keypress\", this);\n    }\n\n    disconnectedCallback() {\n      this.observer.disconnect();\n      this.removeEventListener(\"button-group:selected\", this);\n      this.removeEventListener(\"keydown\", this);\n      this.removeEventListener(\"mousedown\", this);\n      this.getRootNode().removeEventListener(\"keypress\", this);\n    }\n\n    attributeChangedCallback(name) {\n      if (name == \"orientation\") {\n        if (this.isVertical) {\n          this.setAttribute(\"aria-orientation\", this.orientation);\n        } else {\n          this.removeAttribute(\"aria-orientation\");\n        }\n      }\n    }\n\n    setChildAttributes(nodes) {\n      for (let node of nodes) {\n        if (node.nodeType == Node.ELEMENT_NODE && node != this.activeChild) {\n          node.setAttribute(\"tabindex\", \"-1\");\n        }\n      }\n    }\n\n    // The activeChild is the child that can be focused with tab.\n    get activeChild() {\n      return this._activeChild;\n    }\n\n    set activeChild(node) {\n      let prevActiveChild = this._activeChild;\n      let newActiveChild;\n\n      if (node && this.contains(node)) {\n        newActiveChild = node;\n      } else {\n        newActiveChild = this.firstElementChild;\n      }\n\n      this._activeChild = newActiveChild;\n\n      if (newActiveChild) {\n        newActiveChild.setAttribute(\"tabindex\", \"0\");\n      }\n\n      if (prevActiveChild && prevActiveChild != newActiveChild) {\n        prevActiveChild.setAttribute(\"tabindex\", \"-1\");\n      }\n    }\n\n    get isVertical() {\n      return this.orientation == \"vertical\";\n    }\n\n    get orientation() {\n      return this.getAttribute(\"orientation\") == \"vertical\"\n        ? \"vertical\"\n        : \"horizontal\";\n    }\n\n    set orientation(val) {\n      if (val == \"vertical\") {\n        this.setAttribute(\"orientation\", val);\n      } else {\n        this.removeAttribute(\"orientation\");\n      }\n    }\n\n    _navigationKeys() {\n      if (this.isVertical) {\n        return {\n          previousKey: \"ArrowUp\",\n          nextKey: \"ArrowDown\",\n        };\n      }\n      if (document.dir == \"rtl\") {\n        return {\n          previousKey: \"ArrowRight\",\n          nextKey: \"ArrowLeft\",\n        };\n      }\n      return {\n        previousKey: \"ArrowLeft\",\n        nextKey: \"ArrowRight\",\n      };\n    }\n\n    handleEvent(e) {\n      let { previousKey, nextKey } = this._navigationKeys();\n      if (e.type == \"keydown\" && (e.key == previousKey || e.key == nextKey)) {\n        this.setAttribute(\"last-input-type\", \"keyboard\");\n        e.preventDefault();\n        let oldFocus = this.activeChild;\n        this.walker.currentNode = oldFocus;\n        let newFocus;\n        if (e.key == previousKey) {\n          newFocus = this.walker.previousNode();\n        } else {\n          newFocus = this.walker.nextNode();\n        }\n        if (newFocus) {\n          this.activeChild = newFocus;\n          this.dispatchEvent(new CustomEvent(\"button-group:key-selected\"));\n        }\n      } else if (e.type == \"button-group:selected\") {\n        this.activeChild = e.target;\n      } else if (e.type == \"mousedown\") {\n        this.setAttribute(\"last-input-type\", \"mouse\");\n      } else if (e.type == \"keypress\" && e.key == \"Tab\") {\n        this.setAttribute(\"last-input-type\", \"keyboard\");\n      }\n    }\n\n    get walker() {\n      if (!this._walker) {\n        this._walker = document.createTreeWalker(\n          this,\n          NodeFilter.SHOW_ELEMENT,\n          {\n            acceptNode: node => {\n              if (node.hidden || node.disabled) {\n                return NodeFilter.FILTER_REJECT;\n              }\n              node.focus();\n              return this.getRootNode().activeElement == node\n                ? NodeFilter.FILTER_ACCEPT\n                : NodeFilter.FILTER_REJECT;\n            },\n          }\n        );\n      }\n      return this._walker;\n    }\n  }\n  customElements.define(\"button-group\", ButtonGroup);\n\n  /**\n   * A deck that is indexed by the \"name\" attribute of its children. The\n   * <named-deck-button> element is a companion element that can update its state\n   * and change the view of a <named-deck>.\n   *\n   * When the deck is connected it will set the first child as the selected view\n   * if a view is not already selected.\n   *\n   * The deck is implemented using a named slot. Setting a slot directly on a\n   * child element of the deck is not supported.\n   *\n   * You can get or set the selected view by name with the `selectedViewName`\n   * property or by setting the \"selected-view\" attribute.\n   *\n   * <named-deck>\n   *   <section name=\"cats\">Some info about cats.</section>\n   *   <section name=\"dogs\">Some dog stuff.</section>\n   * </named-deck>\n   *\n   * let deck = document.querySelector(\"named-deck\");\n   * deck.selectedViewName == \"cats\"; // Cat info is shown.\n   * deck.selectedViewName = \"dogs\";\n   * deck.selectedViewName == \"dogs\"; // Dog stuff is shown.\n   * deck.setAttribute(\"selected-view\", \"cats\");\n   * deck.selectedViewName == \"cats\"; // Cat info is shown.\n   *\n   * Add the is-tabbed attribute to <named-deck> if you want\n   * each of its children to have a tabpanel role and aria-labelledby\n   * referencing the NamedDeckButton component.\n   */\n  class NamedDeck extends HTMLElement {\n    static get observedAttributes() {\n      return [\"selected-view\"];\n    }\n\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n\n      // Create a slot for the visible content.\n      let selectedSlot = document.createElement(\"slot\");\n      selectedSlot.setAttribute(\"name\", \"selected\");\n      this.shadowRoot.appendChild(selectedSlot);\n\n      this.observer = new MutationObserver(() => {\n        this._setSelectedViewAttributes();\n      });\n    }\n\n    connectedCallback() {\n      if (this.selectedViewName) {\n        // Make sure the selected view is shown.\n        this._setSelectedViewAttributes();\n      } else {\n        // If there's no selected view, default to the first.\n        let firstView = this.firstElementChild;\n        if (firstView) {\n          // This will trigger showing the first view.\n          this.selectedViewName = firstView.getAttribute(\"name\");\n        }\n      }\n      this.observer.observe(this, { childList: true });\n    }\n\n    disconnectedCallback() {\n      this.observer.disconnect();\n    }\n\n    attributeChangedCallback(attr, oldVal, newVal) {\n      if (attr == \"selected-view\" && oldVal != newVal) {\n        // Update the slot attribute on the views.\n        this._setSelectedViewAttributes();\n\n        // Notify that the selected view changed.\n        this.dispatchEvent(new CustomEvent(\"view-changed\"));\n      }\n    }\n\n    get selectedViewName() {\n      return this.getAttribute(\"selected-view\");\n    }\n\n    set selectedViewName(name) {\n      this.setAttribute(\"selected-view\", name);\n    }\n\n    /**\n     * Set the slot attribute on all of the views to ensure only the selected view\n     * is shown.\n     */\n    _setSelectedViewAttributes() {\n      let { selectedViewName } = this;\n      for (let view of this.children) {\n        let name = view.getAttribute(\"name\");\n\n        if (this.hasAttribute(\"is-tabbed\")) {\n          view.setAttribute(\"aria-labelledby\", `${this.id}-button-${name}`);\n          view.setAttribute(\"role\", \"tabpanel\");\n        }\n\n        if (name === selectedViewName) {\n          view.slot = \"selected\";\n        } else {\n          view.slot = \"\";\n        }\n      }\n    }\n  }\n  customElements.define(\"named-deck\", NamedDeck);\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nimport { html } from \"lit.all.mjs\";\n// Imported for side-effects.\nimport \"toolkit-widgets/named-deck.js\";\n\nexport default {\n  title: \"UI Widgets/Named Deck\",\n  component: \"named-deck\",\n  parameters: {\n    status: \"stable\",\n    fluent: `\nnamed-deck-tab-one = Tab 1\nnamed-deck-tab-two = Tab 2\nnamed-deck-tab-three = Tab 3\nnamed-deck-content-one = This is tab 1\nnamed-deck-content-two = This is tab 2\nnamed-deck-content-three = This is tab 3\nbutton-group-one = One\nbutton-group-two = Two\nbutton-group-three = Three\nbutton-group-four = Four\n    `,\n  },\n};\n\nexport const Tabs = () => html`\n  <style>\n    button[selected] {\n      outline: 2px dashed var(--in-content-primary-button-background);\n    }\n  </style>\n  <button-group>\n    <button is=\"named-deck-button\" deck=\"tabs-deck\" name=\"tab-1\" data-l10n-id=\"named-deck-tab-one\"></button>\n    <button is=\"named-deck-button\" deck=\"tabs-deck\" name=\"tab-2\" data-l10n-id=\"named-deck-tab-two\"></button>\n    <button is=\"named-deck-button\" deck=\"tabs-deck\" name=\"tab-3\" data-l10n-id=\"named-deck-tab-three\"></button>\n  </button-group>\n  <named-deck id=\"tabs-deck\" is-tabbed>\n    <p name=\"tab-1\" data-l10n-id=\"named-deck-content-one\"></p>\n    <p name=\"tab-2\" data-l10n-id=\"named-deck-content-two\"></p>\n    <p name=\"tab-3\" data-l10n-id=\"named-deck-content-three\"></p>\n  </named-deck>\n\n  <hr>\n\n  <p>\n    The dashed outline is added for emphasis here. It applies to the button with\n    the <code>selected</code> attribute, but matches the deck's\n    <code>selected-view</code> name.\n  </p>\n\n  <p>\n    These tabs are a combination of <code>button-group</code>,\n    <code>named-deck-button</code>, and <code>named-deck</code>.\n    <ul>\n      <li>\n        <code>button-group</code> makes the tabs a single focusable group,\n        using left/right to switch between focused buttons.\n      </li>\n      <li>\n        <code>named-deck-button</code>s are <code>button</code> subclasses\n        that are used to control the <code>named-deck</code>.\n      </li>\n      <li>\n        <code>named-deck</code> show only one selected child at a time.\n      </li>\n    </ul>\n  </p>\n`;\n\nexport const ListMenu = () => html`\n  <style>\n    .icon-button {\n      background-image: url(\"chrome://global/skin/icons/arrow-left.svg\");\n    }\n\n    .vertical-group {\n      display: flex;\n      flex-direction: column;\n      width: 200px;\n    }\n  </style>\n  <named-deck id=\"list-deck\" is-tabbed>\n    <section name=\"list\">\n      <button-group orientation=\"vertical\" class=\"vertical-group\">\n        <button is=\"named-deck-button\" deck=\"list-deck\" name=\"tab-1\">\n          Tab 1\n        </button>\n        <button is=\"named-deck-button\" deck=\"list-deck\" name=\"tab-2\">\n          Tab 2\n        </button>\n        <button is=\"named-deck-button\" deck=\"list-deck\" name=\"tab-3\">\n          Tab 3\n        </button>\n      </button-group>\n    </section>\n    <section name=\"tab-1\">\n      <button\n        class=\"icon-button ghost-button\"\n        is=\"named-deck-button\"\n        deck=\"list-deck\"\n        name=\"list\"\n      ></button>\n      <p>This is tab 1</p>\n    </section>\n    <section name=\"tab-2\">\n      <button\n        class=\"icon-button ghost-button\"\n        is=\"named-deck-button\"\n        deck=\"list-deck\"\n        name=\"list\"\n      ></button>\n      <p>This is tab 2</p>\n    </section>\n    <section name=\"tab-3\">\n      <button\n        class=\"icon-button ghost-button\"\n        is=\"named-deck-button\"\n        deck=\"list-deck\"\n        name=\"list\"\n      ></button>\n      <p>This is tab 3</p>\n    </section>\n  </named-deck>\n\n  <hr />\n\n  <p>\n    This is an alternate layout for creating a menu navigation. In this case,\n    the first view in the <code>named-deck</code> is the list view which\n    contains the <code>named-deck-button</code>s to link to the other views.\n    Each view then includes a back <code>named-deck-button</code> which is used\n    to navigate back to the first view.\n  </p>\n`;\n\nconst FocusGroupTemplate = ({ orientation }) => html`\n  <button-group orientation=${orientation}>\n    <button data-l10n-id=\"button-group-one\"></button>\n    <button data-l10n-id=\"button-group-two\"></button>\n    <button data-l10n-id=\"button-group-three\"></button>\n    <button data-l10n-id=\"button-group-four\"></button>\n  </button-group>\n\n  <p>\n    The <code>button-group</code> element will group focus to the buttons,\n    requiring left/right or up/down to switch focus between its child elements.\n    It accepts an <code>orientation</code> property, which determines if\n    left/right or up/down are used to change the focused button.\n  </p>\n`;\n\nexport const FocusGroup = FocusGroupTemplate.bind({});\nFocusGroup.args = {\n  orientation: \"horizontal\",\n};\nFocusGroup.argTypes = {\n  orientation: {\n    options: [\"horizontal\", \"vertical\"],\n    control: { type: \"radio\" },\n  },\n};\n"],"names":[],"sourceRoot":""}