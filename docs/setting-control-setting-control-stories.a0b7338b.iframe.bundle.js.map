{"version":3,"file":"setting-control-setting-control-stories.a0b7338b.iframe.bundle.js","mappings":";;;;;;;;;;;;;;;AAAA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxHA;AACA;AACA;;AAEA;AAaA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack:///../preferences/widgets/setting-control/setting-control.stories.mjs","webpack:///../preferences/widgets/setting-control/setting-control.mjs"],"sourcesContent":["/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nimport { html } from \"chrome://global/content/vendor/lit.all.mjs\";\nimport \"chrome://browser/content/preferences/widgets/setting-control.mjs\";\n\nexport default {\n  title: \"Domain-specific UI Widgets/Settings/Setting Control\",\n  component: \"setting-control\",\n  parameters: {\n    status: \"in-development\",\n    handles: [\"click\", \"input\", \"change\"],\n    fluent: `\ncheckbox-example-input =\n  .label = Checkbox example of setting-control\n  .description = Could have a description like moz-checkbox.\nselect-example-input =\n  .label = Select example of setting-control\n  .description = Could have a description like moz-select.\nselect-option-0 =\n  .label = Option 0\nselect-option-1 =\n  .label = Option 1\nselect-option-2 =\n  .label = Option 2\nradio-example-input =\n  .label = Radio example of setting-control\n  .description = Could have a description like moz-radio-group.\nradio-option-0 =\n  .label = Option 0\nradio-option-1 =\n  .label = Option 1\n  .description = It's a full moz-radio\nradio-option-2 =\n  .label = Option 2\n`,\n  },\n};\n\nconst Template = ({ config, setting }) => html`\n  <setting-control .config=${config} .setting=${setting}></setting-control>\n`;\n\nexport const Checkbox = Template.bind({});\nCheckbox.args = {\n  config: {\n    id: \"checkbox-example\",\n    l10nId: \"checkbox-example-input\",\n  },\n  setting: {\n    value: true,\n    on() {},\n    off() {},\n    userChange() {},\n    getControlConfig: c => c,\n  },\n};\n\nexport const Select = Template.bind({});\nSelect.args = {\n  config: {\n    id: \"select-example\",\n    l10nId: \"select-example-input\",\n    control: \"moz-select\",\n    supportPage: \"example-support\",\n    options: [\n      {\n        value: 0,\n        l10nId: \"select-option-0\",\n      },\n      {\n        value: 1,\n        l10nId: \"select-option-1\",\n      },\n      {\n        value: 2,\n        l10nId: \"select-option-2\",\n      },\n    ],\n  },\n  setting: {\n    value: 1,\n    on() {},\n    off() {},\n    userChange() {},\n    getControlConfig: c => c,\n  },\n};\n\nexport const Radio = Template.bind({});\nRadio.args = {\n  config: {\n    id: \"radio-example\",\n    l10nId: \"radio-example-input\",\n    control: \"moz-radio-group\",\n    supportPage: \"example-support\",\n    options: [\n      {\n        value: 0,\n        l10nId: \"radio-option-0\",\n      },\n      {\n        value: 1,\n        l10nId: \"radio-option-1\",\n        supportPage: \"support-page\",\n      },\n      {\n        value: 2,\n        l10nId: \"radio-option-2\",\n      },\n    ],\n  },\n  setting: {\n    value: 1,\n    on() {},\n    off() {},\n    userChange() {},\n    getControlConfig: c => c,\n  },\n};\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nimport {\n  Directive,\n  createRef,\n  directive,\n  html,\n  ifDefined,\n  literal,\n  noChange,\n  nothing,\n  ref,\n  staticHtml,\n  unsafeStatic,\n} from \"chrome://global/content/vendor/lit.all.mjs\";\nimport { MozLitElement } from \"chrome://global/content/lit-utils.mjs\";\n\n/**\n * A Lit directive that applies all properties of an object to a DOM element.\n *\n * This directive interprets keys in the provided props object as follows:\n * - Keys starting with `?` set or remove boolean attributes using `toggleAttribute`.\n * - Keys starting with `.` set properties directly on the element.\n * - Keys starting with `@` are currently not supported and will throw an error.\n * - All other keys are applied as regular attributes using `setAttribute`.\n *\n * It avoids reapplying values that have not changed, but does not currently\n * remove properties that were previously set and are no longer present in the new input.\n *\n * This directive is useful to \"spread\" an object of attributes/properties declaratively onto an\n * element in a Lit template.\n */\nclass SpreadDirective extends Directive {\n  /**\n   * A record of previously applied properties to avoid redundant updates.\n   * @type {Record<string, unknown>}\n   */\n  #prevProps = {};\n\n  /**\n   * Render nothing by default as all changes are made in update using DOM APIs\n   * on the element directly.\n   * @returns {typeof nothing}\n   */\n  render() {\n    return nothing;\n  }\n\n  /**\n   * Apply props to the element using DOM APIs, updating only changed values.\n   * @param {AttributePart} part - The part of the template this directive is bound to.\n   * @param {[Record<string, unknown>]} propsArray - An array with a single object containing props to apply.\n   * @returns {typeof noChange} - Indicates to Lit that no re-render is needed.\n   */\n  update(part, [props]) {\n    // TODO: This doesn't clear any values that were set in previous calls if\n    // they are no longer present.\n    // It isn't entirely clear to me (mstriemer) what we should do if a prop is\n    // removed, or if the prop has changed from say ?foo to foo. By not\n    // implementing the auto-clearing hopefully the consumer will do something\n    // that fits their use case.\n\n    /** @type {HTMLElement} */\n    let el = part.element;\n\n    for (let [key, value] of Object.entries(props)) {\n      // Skip if the value hasn't changed since the last update.\n      if (value === this.#prevProps[key]) {\n        continue;\n      }\n\n      // Update the element based on the property key matching Lit's templates:\n      //   ?key -> el.toggleAttribute(key, value)\n      //   .key -> el.key = value\n      //   key -> el.setAttribute(key, value)\n      if (key.startsWith(\"?\")) {\n        el.toggleAttribute(key.slice(1), Boolean(value));\n      } else if (key.startsWith(\".\")) {\n        el[key.slice(1)] = value;\n      } else if (key.startsWith(\"@\")) {\n        throw new Error(\n          `Event listeners are not yet supported with spread (${key})`\n        );\n      } else {\n        el.setAttribute(key, String(value));\n      }\n    }\n\n    // Save current props for comparison in the next update.\n    this.#prevProps = props;\n\n    return noChange;\n  }\n}\n\nconst spread = directive(SpreadDirective);\n\n/**\n * @type Map<string, HTMLElement>\n */\nconst controlInstances = new Map();\nfunction getControlInstance(control = \"moz-checkbox\") {\n  if (!controlInstances.has(control)) {\n    controlInstances.set(control, document.createElement(control));\n  }\n  return controlInstances.get(control);\n}\n\nconst KNOWN_OPTIONS = new Map([\n  [\"moz-radio-group\", literal`moz-radio`],\n  [\"moz-select\", literal`moz-option`],\n]);\n\nexport class SettingControl extends MozLitElement {\n  #lastSetting;\n\n  static properties = {\n    setting: { type: Object },\n    config: { type: Object },\n    value: {},\n    parentDisabled: { type: Boolean },\n  };\n\n  constructor() {\n    super();\n    this.controlRef = createRef();\n  }\n\n  createRenderRoot() {\n    return this;\n  }\n\n  get controlEl() {\n    return this.controlRef.value;\n  }\n\n  async getUpdateComplete() {\n    let result = await super.getUpdateComplete();\n    await this.controlEl.updateComplete;\n    return result;\n  }\n\n  onSettingChange = () => {\n    this.setValue();\n    this.requestUpdate();\n  };\n\n  willUpdate(changedProperties) {\n    if (changedProperties.has(\"setting\")) {\n      if (this.#lastSetting) {\n        this.#lastSetting.off(\"change\", this.onSettingChange);\n      }\n      this.#lastSetting = this.setting;\n      this.setValue();\n      this.setting.on(\"change\", this.onSettingChange);\n    }\n    this.hidden = !this.setting.visible;\n  }\n\n  /**\n   * The default properties that a control accepts.\n   */\n  getPropertyMapping(config) {\n    const props = {\n      id: config.id,\n      \"data-l10n-id\": config.l10nId,\n      \".iconSrc\": config.iconSrc,\n      \".supportPage\": config.supportPage,\n      \".parentDisabled\": this.parentDisabled,\n      \".control\": this,\n      \"data-subcategory\": config.subcategory,\n      \"?disabled\": this.setting.disabled || this.setting.locked,\n      ...config.controlAttrs,\n    };\n\n    if (config.l10nArgs) {\n      props[\"data-l10n-args\"] = JSON.stringify(config.l10nArgs);\n    }\n\n    // Set the value based on the control's API.\n    let instance = getControlInstance(config.control);\n    if (\"checked\" in instance) {\n      props[\".checked\"] = this.value;\n    } else if (\"pressed\" in instance) {\n      props[\".pressed\"] = this.value;\n    } else if (\"value\" in instance) {\n      props[\".value\"] = this.value;\n    }\n\n    return props;\n  }\n\n  getValue() {\n    return this.setting.value;\n  }\n\n  setValue = () => {\n    this.value = this.setting.value;\n  };\n\n  controlValue(el) {\n    if (el.constructor.activatedProperty && el.localName != \"moz-radio\") {\n      return el[el.constructor.activatedProperty];\n    }\n    return el.value;\n  }\n\n  // Called by our parent when our input changed.\n  onChange(el) {\n    this.setting.userChange(this.controlValue(el));\n  }\n\n  render() {\n    // Allow the Setting to override the static config if necessary.\n    this.config = this.setting.getControlConfig(this.config);\n    let { config } = this;\n    let getItemArgs = items =>\n      items?.map(i => ({\n        config: i,\n        setting: this.getSetting(i.id),\n      })) || [];\n\n    // Prepare nested item config and settings.\n    let itemArgs = getItemArgs(config.items);\n    let itemTemplate = opts =>\n      html`<setting-control\n        .config=${opts.config}\n        .setting=${opts.setting}\n        .getSetting=${this.getSetting}\n        slot=\"nested\"\n      ></setting-control>`;\n    let nestedSettings = itemArgs.map(itemTemplate);\n\n    // Prepare any children that this element may need.\n    let controlChildren = nothing;\n    if (config.options) {\n      controlChildren = config.options.map(opt => {\n        let optionTag = opt.control\n          ? unsafeStatic(opt.control)\n          : KNOWN_OPTIONS.get(config.control);\n        return staticHtml`<${optionTag}\n              id=${ifDefined(opt.id)}\n              .value=${opt.value}\n              .supportPage=${opt.supportPage}\n              .control=${this}\n              data-l10n-id=${opt.l10nId}\n              data-l10n-args=${ifDefined(\n                opt.l10nArgs && JSON.stringify(opt.l10nArgs)\n              )}\n            >${opt.items ? getItemArgs(opt.items).map(itemTemplate) : \"\"}</${optionTag}>`;\n      });\n    }\n\n    // Get the properties for this element: id, fluent, disabled, etc.\n    // These will be applied to the control using the spread directive.\n    let controlProps = this.getPropertyMapping(config);\n\n    let tag = unsafeStatic(config.control || \"moz-checkbox\");\n    return staticHtml`<${tag}\n      ${spread(controlProps)}\n      ${ref(this.controlRef)}\n    >${controlChildren}${nestedSettings}</${tag}>`;\n  }\n}\ncustomElements.define(\"setting-control\", SettingControl);\n"],"names":[],"sourceRoot":""}