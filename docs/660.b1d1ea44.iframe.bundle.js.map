{"version":3,"file":"660.b1d1ea44.iframe.bundle.js","mappings":";;;;;;;;;;AAAA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;AAIA;AAAA;AAAA;AAIA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAIA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AAGA;AAGA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAIA;AAEA;AAIA;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AAGA;AAEA;AACA;AAGA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AACA;AAKA;AAGA;AACA;AAEA;AAGA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AAIA;AAEA;AACA;AAIA;AAEA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAMA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAKA;AAKA;AACA;AAEA;AACA;AACA;AAEA;AAeA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AAKA;AACA;AAIA;AACA;AAIA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AAAA;AAGA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AAGA;;AAOA;AACA;AACA;AACA;AACA;AAIA;AACA;AAIA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAIA;AACA;AACA;AACA;AAEA;;AAOA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAeA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;;AAEA;AACA;AAIA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAGA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAIA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA","sources":["webpack:///../../../toolkit/content/widgets/browser-custom-element.mjs"],"sourcesContent":["/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n// TODO: Bug 1994968 - Fix most TypeScript issues in this file. Currently there\n// are lots of errors that may show up in an editor due to our TypeScript\n// configuration. Skip this for now, until these are resolved.\n\nconst { AppConstants } = ChromeUtils.importESModule(\n  \"resource://gre/modules/AppConstants.sys.mjs\"\n);\n\nconst { XPCOMUtils } = ChromeUtils.importESModule(\n  \"resource://gre/modules/XPCOMUtils.sys.mjs\"\n);\n\nlet lazy = {};\n\nChromeUtils.defineESModuleGetters(lazy, {\n  BrowserUtils: \"resource://gre/modules/BrowserUtils.sys.mjs\",\n  Finder: \"resource://gre/modules/Finder.sys.mjs\",\n  FinderParent: \"resource://gre/modules/FinderParent.sys.mjs\",\n  PopupAndRedirectBlocker:\n    \"resource://gre/actors/PopupAndRedirectBlockingParent.sys.mjs\",\n  SelectParentHelper: \"resource://gre/actors/SelectParent.sys.mjs\",\n  RemoteWebNavigation: \"resource://gre/modules/RemoteWebNavigation.sys.mjs\",\n});\n\nChromeUtils.defineLazyGetter(lazy, \"blankURI\", () =>\n  Services.io.newURI(\"about:blank\")\n);\n\nlet lazyPrefs = {};\nXPCOMUtils.defineLazyPreferenceGetter(\n  lazyPrefs,\n  \"unloadTimeoutMs\",\n  \"dom.beforeunload_timeout_ms\"\n);\n\nObject.defineProperty(lazy, \"ProcessHangMonitor\", {\n  configurable: true,\n  get() {\n    // Import if we can - this is a browser/ module so it may not be\n    // available, in which case we return null. We replace this getter\n    // when the module becomes available (should be on delayed startup\n    // when the first browser window loads, via BrowserGlue.sys.mjs).\n    const kURL = \"resource:///modules/ProcessHangMonitor.sys.mjs\";\n    if (Cu.isESModuleLoaded(kURL)) {\n      let { ProcessHangMonitor } = ChromeUtils.importESModule(kURL);\n      // eslint-disable-next-line mozilla/valid-lazy\n      Object.defineProperty(lazy, \"ProcessHangMonitor\", {\n        value: ProcessHangMonitor,\n      });\n      return ProcessHangMonitor;\n    }\n    return null;\n  },\n});\n\n// Get SessionStore module in the same as ProcessHangMonitor above.\nObject.defineProperty(lazy, \"SessionStore\", {\n  configurable: true,\n  get() {\n    const kURL = \"resource:///modules/sessionstore/SessionStore.sys.mjs\";\n    if (Cu.isESModuleLoaded(kURL)) {\n      let { SessionStore } = ChromeUtils.importESModule(kURL);\n      // eslint-disable-next-line mozilla/valid-lazy\n      Object.defineProperty(lazy, \"SessionStore\", {\n        value: SessionStore,\n      });\n      return SessionStore;\n    }\n    return null;\n  },\n});\n\nconst elementsToDestroyOnUnload = new Set();\n\nwindow.addEventListener(\n  \"unload\",\n  () => {\n    for (let element of elementsToDestroyOnUnload.values()) {\n      element.destroy();\n    }\n    elementsToDestroyOnUnload.clear();\n  },\n  { mozSystemGroup: true, once: true }\n);\n\n/**\n * @implements {nsIBrowser}\n */\nexport class MozBrowser extends MozElements.MozElementMixin(XULFrameElement) {\n  static get observedAttributes() {\n    return [\"remote\"];\n  }\n\n  constructor() {\n    super();\n\n    this.onPageHide = this.onPageHide.bind(this);\n\n    this.isNavigating = false;\n\n    this._documentURI = null;\n    this._characterSet = null;\n    this._documentContentType = null;\n\n    this._inPermitUnload = new WeakSet();\n\n    this._originalURI = null;\n    this._searchTerms = \"\";\n    // When we open a prompt in reaction to a 401, if this 401 comes from\n    // a different base domain, the url of that site will be stored here\n    // and will be used for auth prompt spoofing protections.\n    // See bug 791594 for reference.\n    this._currentAuthPromptURI = null;\n    /**\n     * These are managed by the tabbrowser:\n     */\n    this.droppedLinkHandler = null;\n    this.mIconURL = null;\n    this.lastURI = null;\n\n    ChromeUtils.defineLazyGetter(this, \"popupAndRedirectBlocker\", () => {\n      return new lazy.PopupAndRedirectBlocker(this);\n    });\n\n    this.addEventListener(\n      \"dragover\",\n      event => {\n        if (!this.droppedLinkHandler || event.defaultPrevented) {\n          return;\n        }\n\n        // For drags that appear to be internal text (for example, tab drags),\n        // set the dropEffect to 'none'. This prevents the drop even if some\n        // other listener cancelled the event.\n        var types = event.dataTransfer.types;\n        if (\n          types.includes(\"text/x-moz-text-internal\") &&\n          !types.includes(\"text/plain\")\n        ) {\n          event.dataTransfer.dropEffect = \"none\";\n          event.stopPropagation();\n          event.preventDefault();\n        }\n\n        // No need to handle \"dragover\" in e10s, since nsDocShellTreeOwner.cpp in the child process\n        // handles that case using \"@mozilla.org/content/dropped-link-handler;1\" service.\n        if (this.isRemoteBrowser) {\n          return;\n        }\n\n        let linkHandler = Services.droppedLinkHandler;\n        if (linkHandler.canDropLink(event, false)) {\n          event.preventDefault();\n        }\n      },\n      { mozSystemGroup: true }\n    );\n\n    this.addEventListener(\n      \"drop\",\n      event => {\n        const contentAnalysis = Cc[\"@mozilla.org/contentanalysis;1\"].getService(\n          Ci.nsIContentAnalysis\n        );\n        if (contentAnalysis.isActive) {\n          let dragService = Cc[\"@mozilla.org/widget/dragservice;1\"].getService(\n            Ci.nsIDragService\n          );\n          let dragSession = dragService.getCurrentSession(window);\n          if (!dragSession) {\n            return;\n          }\n\n          try {\n            // Submit a content analysis request for the DataTransfer and\n            // stop dispatching this drop event.  Reissue the drop if all\n            // requests are permitted, otherwise issue a dragexit.\n            let request = {\n              analysisType: Ci.nsIContentAnalysisRequest.eBulkDataEntry,\n              dataTransfer: event.dataTransfer,\n              operationTypeForDisplay:\n                Ci.nsIContentAnalysisRequest.eDroppedText,\n              reason: Ci.nsIContentAnalysisRequest.eDragAndDrop,\n              resources: [],\n              sourceWindowGlobal: dragSession.sourceWindowContext,\n              uri: contentAnalysis.getURIForDropEvent(event),\n              windowGlobalParent: this.browsingContext.currentWindowContext,\n            };\n\n            // Tell browser to record the event target and to delay EndDragSession\n            // until the content analysis results are given.\n            dragSession.sendStoreDropTargetAndDelayEndDragSession(event);\n\n            contentAnalysis.analyzeBatchContentRequest(request, true).then(\n              caResult => {\n                let shouldAllowContent = true;\n                if (caResult.length > 1) {\n                  shouldAllowContent = caResult[1].shouldAllowContent;\n                }\n                dragSession.sendDispatchToDropTargetAndResumeEndDragSession(\n                  shouldAllowContent,\n                  caResult[0]\n                );\n              },\n              () => {\n                dragSession.sendDispatchToDropTargetAndResumeEndDragSession(\n                  false,\n                  []\n                );\n              }\n            );\n\n            // Do not allow this drop to continue dispatch.\n            event.preventDefault();\n            event.stopPropagation();\n          } catch (e) {\n            console.error(`content analysis dnd error: ${e}`);\n\n            // On internal error, deny any drop.  CA has its own behavior to\n            // handle internal errors, like a lost connection to the agent, but\n            // we are more strict when facing errors here.\n            event.preventDefault();\n            event.stopPropagation();\n          }\n        }\n\n        // No need to handle \"drop\" in e10s, since nsDocShellTreeOwner.cpp in the child process\n        // handles that case using \"@mozilla.org/content/dropped-link-handler;1\" service.\n        if (\n          !this.droppedLinkHandler ||\n          event.defaultPrevented ||\n          this.isRemoteBrowser\n        ) {\n          return;\n        }\n\n        let linkHandler = Services.droppedLinkHandler;\n        try {\n          if (!linkHandler.canDropLink(event, false)) {\n            return;\n          }\n\n          // Pass true to prevent the dropping of javascript:/data: URIs\n          var links = linkHandler.dropLinks(event, true);\n        } catch (ex) {\n          return;\n        }\n\n        if (links.length) {\n          let triggeringPrincipal = linkHandler.getTriggeringPrincipal(event);\n          this.droppedLinkHandler(event, links, triggeringPrincipal);\n        }\n      },\n      { mozSystemGroup: true }\n    );\n\n    this.addEventListener(\"dragstart\", event => {\n      // If we're a remote browser dealing with a dragstart, stop it\n      // from propagating up, since our content process should be dealing\n      // with the mouse movement.\n      if (this.isRemoteBrowser) {\n        event.stopPropagation();\n      }\n    });\n  }\n\n  /**\n   * The browser's permanent key. This was added temporarily for Session Store,\n   * and will be removed in bug 1716788.\n   *\n   * @type {any}\n   */\n  permanentKey;\n\n  resetFields() {\n    if (this.observer) {\n      try {\n        Services.obs.removeObserver(\n          this.observer,\n          \"browser:purge-session-history\"\n        );\n      } catch (ex) {\n        // It's not clear why this sometimes throws an exception.\n      }\n      this.observer = null;\n    }\n\n    let browser = this;\n    this.observer = {\n      observe(aSubject, aTopic, aState) {\n        if (aTopic == \"browser:purge-session-history\") {\n          browser.purgeSessionHistory();\n        } else if (aTopic == \"apz:cancel-autoscroll\") {\n          if (aState == browser._autoScrollScrollId) {\n            // Set this._autoScrollScrollId to null, so in stopScroll() we\n            // don't call stopApzAutoscroll() (since it's APZ that\n            // initiated the stopping).\n            browser._autoScrollScrollId = null;\n            browser._autoScrollPresShellId = null;\n\n            browser._autoScrollPopup.hidePopup();\n          }\n        }\n      },\n      QueryInterface: ChromeUtils.generateQI([\n        \"nsIObserver\",\n        \"nsISupportsWeakReference\",\n      ]),\n    };\n\n    this._documentURI = null;\n\n    this._originalURI = null;\n\n    this._currentAuthPromptURI = null;\n\n    this._searchTerms = \"\";\n\n    this._documentContentType = null;\n\n    this._loadContext = null;\n\n    this._webBrowserFind = null;\n\n    this._finder = null;\n\n    this._remoteFinder = null;\n\n    this._fastFind = null;\n\n    this._lastSearchString = null;\n\n    this._characterSet = \"\";\n\n    this._mayEnableCharacterEncodingMenu = null;\n\n    this._contentPrincipal = null;\n\n    this._contentPartitionedPrincipal = null;\n\n    this._policyContainer = null;\n\n    this._referrerInfo = null;\n\n    this._contentRequestContextID = null;\n\n    this._rdmFullZoom = 1.0;\n\n    this._isSyntheticDocument = false;\n\n    this.mPrefs = Services.prefs;\n\n    this._audioMuted = false;\n\n    this._hasAnyPlayingMediaBeenBlocked = false;\n\n    this._unselectedTabHoverMessageListenerCount = 0;\n\n    this.urlbarChangeTracker = {\n      _startedLoadSinceLastUserTyping: false,\n\n      startedLoad() {\n        this._startedLoadSinceLastUserTyping = true;\n      },\n      finishedLoad() {\n        this._startedLoadSinceLastUserTyping = false;\n      },\n      userTyped() {\n        this._startedLoadSinceLastUserTyping = false;\n      },\n    };\n\n    this._userTypedValue = null;\n\n    this._AUTOSCROLL_SNAP = 10;\n\n    this._autoScrollBrowsingContext = null;\n\n    this._startX = null;\n\n    this._startY = null;\n\n    this._autoScrollPopup = null;\n\n    /**\n     * These IDs identify the scroll frame being autoscrolled.\n     */\n    this._autoScrollScrollId = null;\n\n    this._autoScrollPresShellId = null;\n  }\n\n  connectedCallback() {\n    // We typically use this to avoid running JS that triggers a layout during parse\n    // (see comment on the delayConnectedCallback implementation). In this case, we\n    // are using it to avoid a leak - see https://bugzilla.mozilla.org/show_bug.cgi?id=1441935#c20.\n    if (this.delayConnectedCallback()) {\n      return;\n    }\n\n    this.construct();\n  }\n\n  disconnectedCallback() {\n    this.destroy();\n  }\n\n  get autoscrollEnabled() {\n    if (this.getAttribute(\"autoscroll\") == \"false\") {\n      return false;\n    }\n\n    return this.mPrefs.getBoolPref(\"general.autoScroll\", true);\n  }\n\n  get canGoBack() {\n    return this.webNavigation.canGoBack;\n  }\n\n  get canGoBackIgnoringUserInteraction() {\n    return this.webNavigation.canGoBackIgnoringUserInteraction;\n  }\n\n  get canGoForward() {\n    return this.webNavigation.canGoForward;\n  }\n\n  // While an auth prompt from a base domain different than the current sites is open, we want to display the url of the cross domain site.\n  // This is to prevent possible auth spoofing scenarios.\n  // The URL of the requesting origin is provided by 'currentAuthPromptURI', this will only be non null while an auth prompt is open.\n  // See bug 791594 for reference.\n  get currentURI() {\n    if (this.currentAuthPromptURI) {\n      return this.currentAuthPromptURI;\n    }\n    if (this.webNavigation) {\n      return this.webNavigation.currentURI;\n    }\n    return null;\n  }\n\n  get documentURI() {\n    return this.isRemoteBrowser\n      ? this._documentURI\n      : this.contentDocument?.documentURIObject;\n  }\n\n  get documentContentType() {\n    if (this.isRemoteBrowser) {\n      return this._documentContentType;\n    }\n    return this.contentDocument ? this.contentDocument.contentType : null;\n  }\n\n  set documentContentType(aContentType) {\n    if (aContentType != null) {\n      if (this.isRemoteBrowser) {\n        this._documentContentType = aContentType;\n      } else {\n        this.contentDocument.documentContentType = aContentType;\n      }\n    }\n  }\n\n  get loadContext() {\n    if (this._loadContext) {\n      return this._loadContext;\n    }\n\n    let { frameLoader } = this;\n    if (!frameLoader) {\n      return null;\n    }\n    this._loadContext = frameLoader.loadContext;\n    return this._loadContext;\n  }\n\n  get autoCompletePopup() {\n    return document.getElementById(this.getAttribute(\"autocompletepopup\"));\n  }\n\n  set suspendMediaWhenInactive(val) {\n    this.browsingContext.suspendMediaWhenInactive = val;\n  }\n\n  get suspendMediaWhenInactive() {\n    return !!this.browsingContext?.suspendMediaWhenInactive;\n  }\n\n  set docShellIsActive(val) {\n    if (!this.browsingContext) {\n      return;\n    }\n    this.browsingContext.isActive = val;\n    if (this.isRemoteBrowser) {\n      let remoteTab = this.frameLoader?.remoteTab;\n      if (remoteTab) {\n        remoteTab.renderLayers = val;\n      }\n    }\n  }\n\n  get docShellIsActive() {\n    return !!this.browsingContext?.isActive;\n  }\n\n  set renderLayers(val) {\n    if (this.isRemoteBrowser) {\n      let remoteTab = this.frameLoader?.remoteTab;\n      if (remoteTab) {\n        remoteTab.renderLayers = val;\n      }\n    } else {\n      this.docShellIsActive = val;\n    }\n  }\n\n  get renderLayers() {\n    if (this.isRemoteBrowser) {\n      return !!this.frameLoader?.remoteTab?.renderLayers;\n    }\n    return this.docShellIsActive;\n  }\n\n  get hasLayers() {\n    if (this.isRemoteBrowser) {\n      return !!this.frameLoader?.remoteTab?.hasLayers;\n    }\n    return this.docShellIsActive;\n  }\n\n  get isRemoteBrowser() {\n    return this.getAttribute(\"remote\") == \"true\";\n  }\n\n  get remoteType() {\n    return this.browsingContext?.currentRemoteType;\n  }\n\n  get isCrashed() {\n    if (!this.isRemoteBrowser || !this.frameLoader) {\n      return false;\n    }\n\n    return !this.frameLoader.remoteTab;\n  }\n\n  get messageManager() {\n    // Bug 1524084 - Trying to get at the message manager while in the crashed state will\n    // create a new message manager that won't shut down properly when the crashed browser\n    // is removed from the DOM. We work around that right now by returning null if we're\n    // in the crashed state.\n    if (this.frameLoader && !this.isCrashed) {\n      return this.frameLoader.messageManager;\n    }\n    return null;\n  }\n\n  get webBrowserFind() {\n    if (!this._webBrowserFind) {\n      this._webBrowserFind = this.docShell\n        .QueryInterface(Ci.nsIInterfaceRequestor)\n        .getInterface(Ci.nsIWebBrowserFind);\n    }\n    return this._webBrowserFind;\n  }\n\n  get finder() {\n    if (this.isRemoteBrowser) {\n      if (!this._remoteFinder) {\n        this._remoteFinder = new lazy.FinderParent(this);\n      }\n      return this._remoteFinder;\n    }\n    if (!this._finder) {\n      if (!this.docShell) {\n        return null;\n      }\n\n      this._finder = new lazy.Finder(this.docShell);\n    }\n    return this._finder;\n  }\n\n  get fastFind() {\n    if (!this._fastFind) {\n      if (!(\"@mozilla.org/typeaheadfind;1\" in Cc)) {\n        return null;\n      }\n\n      var tabBrowser = this.getTabBrowser();\n      if (tabBrowser && \"fastFind\" in tabBrowser) {\n        return (this._fastFind = tabBrowser.fastFind);\n      }\n\n      if (!this.docShell) {\n        return null;\n      }\n\n      this._fastFind = Cc[\"@mozilla.org/typeaheadfind;1\"].createInstance(\n        Ci.nsITypeAheadFind\n      );\n      this._fastFind.init(this.docShell);\n    }\n    return this._fastFind;\n  }\n\n  get outerWindowID() {\n    return this.browsingContext?.currentWindowGlobal?.outerWindowId;\n  }\n\n  get innerWindowID() {\n    return this.browsingContext?.currentWindowGlobal?.innerWindowId || null;\n  }\n\n  get browsingContext() {\n    if (this.frameLoader) {\n      return this.frameLoader.browsingContext;\n    }\n    return null;\n  }\n  /**\n   * Note that this overrides webNavigation on XULFrameElement, and duplicates the return value for the non-remote case\n   */\n  get webNavigation() {\n    return this.isRemoteBrowser\n      ? this._remoteWebNavigation\n      : this.docShell && this.docShell.QueryInterface(Ci.nsIWebNavigation);\n  }\n\n  get webProgress() {\n    return this.browsingContext?.webProgress;\n  }\n\n  get sessionHistory() {\n    return this.webNavigation.sessionHistory;\n  }\n\n  get contentTitle() {\n    return (\n      (this.isRemoteBrowser\n        ? this.browsingContext?.currentWindowGlobal?.documentTitle\n        : this.contentDocument.title) ?? \"\"\n    );\n  }\n\n  forceEncodingDetection() {\n    if (this.isRemoteBrowser) {\n      this.sendMessageToActor(\"ForceEncodingDetection\", {}, \"BrowserTab\");\n    } else {\n      this.docShell.forceEncodingDetection();\n    }\n  }\n\n  get characterSet() {\n    return this.isRemoteBrowser ? this._characterSet : this.docShell.charset;\n  }\n\n  get mayEnableCharacterEncodingMenu() {\n    return this.isRemoteBrowser\n      ? this._mayEnableCharacterEncodingMenu\n      : this.docShell.mayEnableCharacterEncodingMenu;\n  }\n\n  set mayEnableCharacterEncodingMenu(aMayEnable) {\n    if (this.isRemoteBrowser) {\n      this._mayEnableCharacterEncodingMenu = aMayEnable;\n    }\n  }\n\n  get contentPrincipal() {\n    return this.isRemoteBrowser\n      ? this._contentPrincipal\n      : this.contentDocument.nodePrincipal;\n  }\n\n  get contentPartitionedPrincipal() {\n    return this.isRemoteBrowser\n      ? this._contentPartitionedPrincipal\n      : this.contentDocument.partitionedPrincipal;\n  }\n\n  get cookieJarSettings() {\n    return this.isRemoteBrowser\n      ? this.browsingContext?.currentWindowGlobal?.cookieJarSettings\n      : this.contentDocument.cookieJarSettings;\n  }\n\n  get policyContainer() {\n    return this.isRemoteBrowser\n      ? this._policyContainer\n      : this.contentDocument.policyContainer;\n  }\n\n  get contentRequestContextID() {\n    if (this.isRemoteBrowser) {\n      return this._contentRequestContextID;\n    }\n    try {\n      return this.contentDocument.documentLoadGroup.requestContextID;\n    } catch (e) {\n      return null;\n    }\n  }\n\n  get referrerInfo() {\n    return this.isRemoteBrowser\n      ? this._referrerInfo\n      : this.contentDocument.referrerInfo;\n  }\n\n  set fullZoom(val) {\n    if (val.toFixed(2) == this.fullZoom.toFixed(2)) {\n      return;\n    }\n    if (this.browsingContext.inRDMPane) {\n      this._rdmFullZoom = val;\n      let event = document.createEvent(\"Events\");\n      event.initEvent(\"FullZoomChange\", true, false);\n      this.dispatchEvent(event);\n    } else {\n      this.browsingContext.fullZoom = val;\n    }\n  }\n\n  get fullZoom() {\n    if (this.browsingContext.inRDMPane) {\n      return this._rdmFullZoom;\n    }\n    return this.browsingContext.fullZoom;\n  }\n\n  set textZoom(val) {\n    if (val.toFixed(2) == this.textZoom.toFixed(2)) {\n      return;\n    }\n    this.browsingContext.textZoom = val;\n  }\n\n  get textZoom() {\n    return this.browsingContext.textZoom;\n  }\n\n  enterResponsiveMode() {\n    if (this.browsingContext.inRDMPane) {\n      return;\n    }\n    this.browsingContext.inRDMPane = true;\n    this._rdmFullZoom = this.browsingContext.fullZoom;\n    this.browsingContext.fullZoom = 1.0;\n  }\n\n  leaveResponsiveMode() {\n    if (!this.browsingContext.inRDMPane) {\n      return;\n    }\n    this.browsingContext.inRDMPane = false;\n    this.browsingContext.fullZoom = this._rdmFullZoom;\n  }\n\n  get isSyntheticDocument() {\n    if (this.isRemoteBrowser) {\n      return this._isSyntheticDocument;\n    }\n    return this.contentDocument.mozSyntheticDocument;\n  }\n\n  get hasContentOpener() {\n    return !!this.browsingContext.opener;\n  }\n\n  get audioMuted() {\n    return this._audioMuted;\n  }\n\n  get shouldHandleUnselectedTabHover() {\n    return this._unselectedTabHoverMessageListenerCount > 0;\n  }\n\n  set shouldHandleUnselectedTabHover(value) {\n    this._unselectedTabHoverMessageListenerCount += value ? 1 : -1;\n  }\n\n  get securityUI() {\n    return this.browsingContext.secureBrowserUI;\n  }\n\n  set userTypedValue(val) {\n    this.urlbarChangeTracker.userTyped();\n    this._userTypedValue = val;\n  }\n\n  get userTypedValue() {\n    return this._userTypedValue;\n  }\n\n  get dontPromptAndDontUnload() {\n    return 1;\n  }\n\n  get dontPromptAndUnload() {\n    return 2;\n  }\n\n  set originalURI(aURI) {\n    if (aURI instanceof Ci.nsIURI) {\n      this._originalURI = aURI;\n    }\n  }\n\n  get originalURI() {\n    return this._originalURI;\n  }\n\n  set searchTerms(val) {\n    this._searchTerms = val;\n  }\n\n  get searchTerms() {\n    return this._searchTerms;\n  }\n\n  set currentAuthPromptURI(aURI) {\n    this._currentAuthPromptURI = aURI;\n  }\n\n  get currentAuthPromptURI() {\n    return this._currentAuthPromptURI;\n  }\n  _wrapURIChangeCall(fn) {\n    if (!this.isRemoteBrowser) {\n      this.isNavigating = true;\n      try {\n        fn();\n      } finally {\n        this.isNavigating = false;\n      }\n    } else {\n      fn();\n    }\n  }\n\n  processCloseRequest() {\n    this.browsingContext.currentWindowContext?.processCloseRequest();\n  }\n\n  goBack(\n    requireUserInteraction = lazy.BrowserUtils.navigationRequireUserInteraction\n  ) {\n    var webNavigation = this.webNavigation;\n    if (\n      requireUserInteraction\n        ? webNavigation.canGoBack\n        : webNavigation.canGoBackIgnoringUserInteraction\n    ) {\n      this._wrapURIChangeCall(() =>\n        webNavigation.goBack(requireUserInteraction)\n      );\n    }\n  }\n\n  goForward(\n    requireUserInteraction = lazy.BrowserUtils.navigationRequireUserInteraction\n  ) {\n    var webNavigation = this.webNavigation;\n    if (webNavigation.canGoForward) {\n      this._wrapURIChangeCall(() =>\n        webNavigation.goForward(requireUserInteraction)\n      );\n    }\n  }\n\n  reload() {\n    const nsIWebNavigation = Ci.nsIWebNavigation;\n    const flags = nsIWebNavigation.LOAD_FLAGS_NONE;\n    this.reloadWithFlags(flags);\n  }\n\n  reloadWithFlags(aFlags) {\n    this.webNavigation.reload(aFlags);\n  }\n\n  stop() {\n    const nsIWebNavigation = Ci.nsIWebNavigation;\n    const flags = nsIWebNavigation.STOP_ALL;\n    this.webNavigation.stop(flags);\n  }\n\n  /**\n   * throws exception for unknown schemes\n   */\n  loadURI(uri, params = {}) {\n    if (!uri) {\n      uri = lazy.blankURI;\n    }\n    this._wrapURIChangeCall(() => this.webNavigation.loadURI(uri, params));\n  }\n\n  /**\n   * throws exception for unknown schemes\n   */\n  fixupAndLoadURIString(uriString, params = {}) {\n    if (!uriString) {\n      this.loadURI(null, params);\n      return;\n    }\n    this._wrapURIChangeCall(() =>\n      this.webNavigation.fixupAndLoadURIString(uriString, params)\n    );\n  }\n\n  gotoIndex(aIndex) {\n    this._wrapURIChangeCall(() => this.webNavigation.gotoIndex(aIndex));\n  }\n\n  preserveLayers(preserve) {\n    if (!this.isRemoteBrowser) {\n      return;\n    }\n    let { frameLoader } = this;\n    if (frameLoader.remoteTab) {\n      frameLoader.remoteTab.preserveLayers(preserve);\n    }\n  }\n\n  deprioritize() {\n    if (!this.isRemoteBrowser) {\n      return;\n    }\n    let { remoteTab } = this.frameLoader;\n    if (remoteTab) {\n      remoteTab.priorityHint = false;\n      remoteTab.deprioritize();\n    }\n  }\n\n  getTabBrowser() {\n    if (this?.ownerGlobal?.gBrowser?.getTabForBrowser(this)) {\n      return this.ownerGlobal.gBrowser;\n    }\n    return null;\n  }\n\n  addProgressListener(aListener, aNotifyMask) {\n    if (!aNotifyMask) {\n      aNotifyMask = Ci.nsIWebProgress.NOTIFY_ALL;\n    }\n\n    this.webProgress.addProgressListener(aListener, aNotifyMask);\n  }\n\n  removeProgressListener(aListener) {\n    this.webProgress.removeProgressListener(aListener);\n  }\n\n  onPageHide() {\n    // If we're browsing from the tab crashed UI to a URI that keeps\n    // this browser non-remote, we'll handle that here.\n    lazy.SessionStore?.maybeExitCrashedState(this);\n\n    if (!this.docShell || !this.fastFind) {\n      return;\n    }\n    var tabBrowser = this.getTabBrowser();\n    if (\n      !tabBrowser ||\n      !(\"fastFind\" in tabBrowser) ||\n      tabBrowser.selectedBrowser == this\n    ) {\n      this.fastFind.setDocShell(this.docShell);\n    }\n  }\n\n  audioPlaybackStarted() {\n    if (this._audioMuted) {\n      return;\n    }\n    let event = document.createEvent(\"Events\");\n    event.initEvent(\"DOMAudioPlaybackStarted\", true, false);\n    this.dispatchEvent(event);\n  }\n\n  audioPlaybackStopped() {\n    let event = document.createEvent(\"Events\");\n    event.initEvent(\"DOMAudioPlaybackStopped\", true, false);\n    this.dispatchEvent(event);\n  }\n\n  /**\n   * When the pref \"media.block-autoplay-until-in-foreground\" is on,\n   * Gecko delays starting playback of media resources in tabs until the\n   * tab has been in the foreground or resumed by tab's play tab icon.\n   * - When Gecko delays starting playback of a media resource in a window,\n   * it sends a message to call activeMediaBlockStarted(). This causes the\n   * tab audio indicator to show.\n   * - When a tab is foregrounded, Gecko starts playing all delayed media\n   * resources in that tab, and sends a message to call\n   * activeMediaBlockStopped(). This causes the tab audio indicator to hide.\n   */\n  activeMediaBlockStarted() {\n    this._hasAnyPlayingMediaBeenBlocked = true;\n    let event = document.createEvent(\"Events\");\n    event.initEvent(\"DOMAudioPlaybackBlockStarted\", true, false);\n    this.dispatchEvent(event);\n  }\n\n  activeMediaBlockStopped() {\n    if (!this._hasAnyPlayingMediaBeenBlocked) {\n      return;\n    }\n    this._hasAnyPlayingMediaBeenBlocked = false;\n    let event = document.createEvent(\"Events\");\n    event.initEvent(\"DOMAudioPlaybackBlockStopped\", true, false);\n    this.dispatchEvent(event);\n  }\n\n  mute(transientState) {\n    if (!transientState) {\n      this._audioMuted = true;\n    }\n    let context = this.frameLoader.browsingContext;\n    context.notifyMediaMutedChanged(true);\n  }\n\n  unmute() {\n    this._audioMuted = false;\n    let context = this.frameLoader.browsingContext;\n    context.notifyMediaMutedChanged(false);\n  }\n\n  resumeMedia() {\n    this.frameLoader.browsingContext.notifyStartDelayedAutoplayMedia();\n    if (this._hasAnyPlayingMediaBeenBlocked) {\n      this._hasAnyPlayingMediaBeenBlocked = false;\n      let event = document.createEvent(\"Events\");\n      event.initEvent(\"DOMAudioPlaybackBlockStopped\", true, false);\n      this.dispatchEvent(event);\n    }\n  }\n\n  unselectedTabHover(hovered) {\n    if (!this.shouldHandleUnselectedTabHover) {\n      return;\n    }\n    this.sendMessageToActor(\n      \"Browser:UnselectedTabHover\",\n      {\n        hovered,\n      },\n      \"UnselectedTabHover\",\n      \"roots\"\n    );\n  }\n\n  didStartLoadSinceLastUserTyping() {\n    return (\n      !this.isNavigating &&\n      this.urlbarChangeTracker._startedLoadSinceLastUserTyping\n    );\n  }\n\n  constrainPopup(popup) {\n    if (this.getAttribute(\"constrainpopups\") != \"false\") {\n      let constraintRect = this.getBoundingClientRect();\n      constraintRect = new DOMRect(\n        constraintRect.left + window.mozInnerScreenX,\n        constraintRect.top + window.mozInnerScreenY,\n        constraintRect.width,\n        constraintRect.height\n      );\n      popup.setConstraintRect(constraintRect);\n    } else {\n      popup.setConstraintRect(new DOMRect(0, 0, 0, 0));\n    }\n  }\n\n  construct() {\n    elementsToDestroyOnUnload.add(this);\n    this.resetFields();\n    this.mInitialized = true;\n    if (this.isRemoteBrowser) {\n      /*\n       * Don't try to send messages from this function. The message manager for\n       * the <browser> element may not be initialized yet.\n       */\n\n      this._remoteWebNavigation = new lazy.RemoteWebNavigation(this);\n\n      // Initialize contentPrincipal to the about:blank principal for this loadcontext\n      let aboutBlank = Services.io.newURI(\"about:blank\");\n      let ssm = Services.scriptSecurityManager;\n      this._contentPrincipal = ssm.getLoadContextContentPrincipal(\n        aboutBlank,\n        this.loadContext\n      );\n      this._contentPartitionedPrincipal = this._contentPrincipal;\n      // policyContainer for about:blank is null; if we ever change _contentPrincipal above,\n      // we should re-evaluate the policyContainer here.\n      this._policyContainer = null;\n\n      if (!this.hasAttribute(\"disablehistory\")) {\n        Services.obs.addObserver(\n          this.observer,\n          \"browser:purge-session-history\",\n          true\n        );\n      }\n    }\n\n    try {\n      // |webNavigation.sessionHistory| will have been set by the frame\n      // loader when creating the docShell as long as this xul:browser\n      // doesn't have the 'disablehistory' attribute set.\n      if (this.docShell && this.webNavigation.sessionHistory) {\n        Services.obs.addObserver(\n          this.observer,\n          \"browser:purge-session-history\",\n          true\n        );\n\n        // enable global history if we weren't told otherwise\n        if (\n          !this.hasAttribute(\"disableglobalhistory\") &&\n          !this.isRemoteBrowser\n        ) {\n          try {\n            this.docShell.browsingContext.useGlobalHistory = true;\n          } catch (ex) {\n            // This can occur if the Places database is locked\n            console.error(\"Error enabling browser global history: \", ex);\n          }\n        }\n      }\n    } catch (e) {\n      console.error(e);\n    }\n    try {\n      // Ensures the securityUI is initialized.\n      var securityUI = this.securityUI; // eslint-disable-line no-unused-vars\n    } catch (e) {}\n\n    if (!this.isRemoteBrowser) {\n      this._remoteWebNavigation = null;\n      this.addEventListener(\"pagehide\", this.onPageHide, true);\n    }\n  }\n\n  /**\n   * This is necessary because custom elements don't have a \"real\" destructor.\n   * This method is called explicitly by tabbrowser, when changing remoteness,\n   * and when we're disconnected or the window unloads.\n   */\n  destroy() {\n    elementsToDestroyOnUnload.delete(this);\n\n    // If we're browsing from the tab crashed UI to a URI that causes the tab\n    // to go remote again, we catch this here, because swapping out the\n    // non-remote browser for a remote one doesn't cause the pagehide event\n    // to be fired. Previously, we used to do this in the frame script's\n    // unload handler.\n    lazy.SessionStore?.maybeExitCrashedState(this);\n\n    // Make sure that any open select is closed.\n    let menulist = document.getElementById(\"ContentSelectDropdown\");\n    if (menulist?.open) {\n      lazy.SelectParentHelper.hide(menulist, this);\n    }\n\n    this.resetFields();\n\n    if (!this.mInitialized) {\n      return;\n    }\n\n    this.mInitialized = false;\n    this.lastURI = null;\n\n    if (!this.isRemoteBrowser) {\n      this.removeEventListener(\"pagehide\", this.onPageHide, true);\n    }\n  }\n\n  updateForStateChange(aCharset, aDocumentURI, aContentType) {\n    if (this.isRemoteBrowser && this.messageManager) {\n      if (aCharset != null) {\n        this._characterSet = aCharset;\n      }\n\n      if (aDocumentURI != null) {\n        this._documentURI = aDocumentURI;\n      }\n\n      if (aContentType != null) {\n        this._documentContentType = aContentType;\n      }\n    }\n  }\n\n  updateWebNavigationForLocationChange(\n    aCanGoBack,\n    aCanGoBackIgnoringUserInteraction,\n    aCanGoForward\n  ) {\n    if (\n      this.isRemoteBrowser &&\n      this.messageManager &&\n      !Services.appinfo.sessionHistoryInParent\n    ) {\n      this._remoteWebNavigation._canGoBack = aCanGoBack;\n      this._remoteWebNavigation._canGoBackIgnoringUserInteraction =\n        aCanGoBackIgnoringUserInteraction;\n      this._remoteWebNavigation._canGoForward = aCanGoForward;\n    }\n  }\n\n  updateForLocationChange(\n    aLocation,\n    aCharset,\n    aMayEnableCharacterEncodingMenu,\n    aDocumentURI,\n    aTitle,\n    aContentPrincipal,\n    aContentPartitionedPrincipal,\n    aPolicyContainer,\n    aReferrerInfo,\n    aIsSynthetic,\n    aHaveRequestContextID,\n    aRequestContextID,\n    aContentType\n  ) {\n    if (this.isRemoteBrowser && this.messageManager) {\n      if (aCharset != null) {\n        this._characterSet = aCharset;\n        this._mayEnableCharacterEncodingMenu = aMayEnableCharacterEncodingMenu;\n      }\n\n      if (aContentType != null) {\n        this._documentContentType = aContentType;\n      }\n\n      this._remoteWebNavigation._currentURI = aLocation;\n      this._documentURI = aDocumentURI;\n      this._contentPrincipal = aContentPrincipal;\n      this._contentPartitionedPrincipal = aContentPartitionedPrincipal;\n      this._policyContainer = aPolicyContainer;\n      this._referrerInfo = aReferrerInfo;\n      this._isSyntheticDocument = aIsSynthetic;\n      this._contentRequestContextID = aHaveRequestContextID\n        ? aRequestContextID\n        : null;\n    }\n  }\n\n  purgeSessionHistory() {\n    if (this.isRemoteBrowser && !Services.appinfo.sessionHistoryInParent) {\n      this._remoteWebNavigation._canGoBack = false;\n      this._remoteWebNavigation._canGoBackIgnoringUserInteraction = false;\n      this._remoteWebNavigation._canGoForward = false;\n    }\n\n    try {\n      if (Services.appinfo.sessionHistoryInParent) {\n        let sessionHistory = this.browsingContext?.sessionHistory;\n        if (!sessionHistory) {\n          return;\n        }\n\n        // place the entry at current index at the end of the history list, so it won't get removed\n        if (sessionHistory.index < sessionHistory.count - 1) {\n          let indexEntry = sessionHistory.getEntryAtIndex(sessionHistory.index);\n          sessionHistory.addEntry(indexEntry, true);\n        }\n\n        let purge = sessionHistory.count;\n        if (\n          this.browsingContext.currentWindowGlobal.documentURI != \"about:blank\"\n        ) {\n          --purge; // Don't remove the page the user's staring at from shistory\n        }\n\n        if (purge > 0) {\n          sessionHistory.purgeHistory(purge);\n        }\n\n        return;\n      }\n\n      this.sendMessageToActor(\n        \"Browser:PurgeSessionHistory\",\n        {},\n        \"PurgeSessionHistory\",\n        \"roots\"\n      );\n    } catch (ex) {\n      // This can throw if the browser has started to go away.\n      if (ex.result != Cr.NS_ERROR_NOT_INITIALIZED) {\n        throw ex;\n      }\n    }\n  }\n\n  createAboutBlankDocumentViewer(aPrincipal, aPartitionedPrincipal) {\n    let principal = lazy.BrowserUtils.principalWithMatchingOA(\n      aPrincipal,\n      this.contentPrincipal\n    );\n    let partitionedPrincipal = lazy.BrowserUtils.principalWithMatchingOA(\n      aPartitionedPrincipal,\n      this.contentPartitionedPrincipal\n    );\n\n    if (this.isRemoteBrowser) {\n      this.frameLoader.remoteTab.createAboutBlankDocumentViewer(\n        principal,\n        partitionedPrincipal\n      );\n    } else {\n      this.docShell.createAboutBlankDocumentViewer(\n        principal,\n        partitionedPrincipal\n      );\n    }\n  }\n\n  _acquireAutoScrollWakeLock() {\n    const pm = Cc[\"@mozilla.org/power/powermanagerservice;1\"].getService(\n      Ci.nsIPowerManagerService\n    );\n    this._autoScrollWakelock = pm.newWakeLock(\"autoscroll\", window);\n  }\n\n  _releaseAutoScrollWakeLock() {\n    if (this._autoScrollWakelock) {\n      try {\n        this._autoScrollWakelock.unlock();\n      } catch (e) {\n        // Ignore error since wake lock is already unlocked\n      }\n      this._autoScrollWakelock = null;\n    }\n  }\n\n  stopScroll() {\n    if (this._autoScrollBrowsingContext) {\n      window.removeEventListener(\"mousemove\", this, true);\n      window.removeEventListener(\"mousedown\", this, true);\n      window.removeEventListener(\"mouseup\", this, true);\n      window.removeEventListener(\"DOMMouseScroll\", this, true);\n      window.removeEventListener(\"contextmenu\", this, true);\n      window.removeEventListener(\"keydown\", this, true);\n      window.removeEventListener(\"keypress\", this, true);\n      window.removeEventListener(\"keyup\", this, true);\n\n      let autoScrollWnd = this._autoScrollBrowsingContext.currentWindowGlobal;\n      if (autoScrollWnd) {\n        autoScrollWnd\n          .getActor(\"AutoScroll\")\n          .sendAsyncMessage(\"Autoscroll:Stop\", {});\n      }\n\n      try {\n        Services.obs.removeObserver(this.observer, \"apz:cancel-autoscroll\");\n      } catch (ex) {\n        // It's not clear why this sometimes throws an exception\n      }\n\n      if (this._autoScrollScrollId != null) {\n        this._autoScrollBrowsingContext.stopApzAutoscroll(\n          this._autoScrollScrollId,\n          this._autoScrollPresShellId\n        );\n\n        this._autoScrollScrollId = null;\n        this._autoScrollPresShellId = null;\n      }\n\n      this._autoScrollBrowsingContext = null;\n      this._releaseAutoScrollWakeLock();\n    }\n  }\n\n  _getAndMaybeCreateAutoScrollPopup() {\n    let autoscrollPopup = document.getElementById(\"autoscroller\");\n    if (!autoscrollPopup) {\n      autoscrollPopup = document.createXULElement(\"panel\");\n      autoscrollPopup.className = \"autoscroller\";\n      autoscrollPopup.setAttribute(\"consumeoutsideclicks\", \"true\");\n      autoscrollPopup.setAttribute(\"rolluponmousewheel\", \"true\");\n      autoscrollPopup.id = \"autoscroller\";\n    }\n\n    return autoscrollPopup;\n  }\n\n  startScroll({\n    scrolldir,\n    screenXDevPx,\n    screenYDevPx,\n    scrollId,\n    presShellId,\n    browsingContext,\n  }) {\n    if (!this.autoscrollEnabled) {\n      return { autoscrollEnabled: false, usingApz: false };\n    }\n\n    // The popup size is 32px for the circle plus space for a 4px box-shadow\n    // on each side.\n    const POPUP_SIZE = 40;\n    if (!this._autoScrollPopup) {\n      this._autoScrollPopup = this._getAndMaybeCreateAutoScrollPopup();\n      document.documentElement.appendChild(this._autoScrollPopup);\n      this._autoScrollPopup.removeAttribute(\"hidden\");\n      this._autoScrollPopup.setAttribute(\"noautofocus\", \"true\");\n      this._autoScrollPopup.style.height = POPUP_SIZE + \"px\";\n      this._autoScrollPopup.style.width = POPUP_SIZE + \"px\";\n      this._autoScrollPopup.style.margin = -POPUP_SIZE / 2 + \"px\";\n    }\n\n    // In desktop pixels.\n    let screenXDesktopPx = screenXDevPx / window.desktopToDeviceScale;\n    let screenYDesktopPx = screenYDevPx / window.desktopToDeviceScale;\n\n    let screenManager = Cc[\"@mozilla.org/gfx/screenmanager;1\"].getService(\n      Ci.nsIScreenManager\n    );\n    let screen = screenManager.screenForRect(\n      screenXDesktopPx,\n      screenYDesktopPx,\n      1,\n      1\n    );\n\n    // we need these attributes so themers don't need to create per-platform packages\n    if (screen.colorDepth > 8) {\n      // need high color for transparency\n      // Exclude second-rate platforms\n      this._autoScrollPopup.setAttribute(\n        \"transparent\",\n        !/BeOS|OS\\/2/.test(navigator.appVersion)\n      );\n      // Enable translucency on Windows and Mac\n      this._autoScrollPopup.setAttribute(\n        \"translucent\",\n        AppConstants.platform == \"win\" || AppConstants.platform == \"macosx\"\n      );\n    }\n\n    this._autoScrollPopup.setAttribute(\"scrolldir\", scrolldir);\n    this._autoScrollPopup.addEventListener(\"popuphidden\", this, true);\n\n    // In CSS pixels\n    let popupX;\n    let popupY;\n    {\n      let cssToDesktopScale =\n        window.devicePixelRatio / window.desktopToDeviceScale;\n\n      // Sanitize screenX/screenY for available screen size with half the size\n      // of the popup removed. The popup uses negative margins to center on the\n      // coordinates we pass. Use desktop pixels to deal correctly with\n      // multi-monitor / multi-dpi scenarios.\n      let left = {},\n        top = {},\n        width = {},\n        height = {};\n      screen.GetAvailRectDisplayPix(left, top, width, height);\n\n      let popupSizeDesktopPx = POPUP_SIZE * cssToDesktopScale;\n      let minX = left.value + 0.5 * popupSizeDesktopPx;\n      let maxX = left.value + width.value - 0.5 * popupSizeDesktopPx;\n      let minY = top.value + 0.5 * popupSizeDesktopPx;\n      let maxY = top.value + height.value - 0.5 * popupSizeDesktopPx;\n\n      popupX =\n        Math.max(minX, Math.min(maxX, screenXDesktopPx)) / cssToDesktopScale;\n      popupY =\n        Math.max(minY, Math.min(maxY, screenYDesktopPx)) / cssToDesktopScale;\n    }\n\n    // In CSS pixels.\n    let screenX = screenXDevPx / window.devicePixelRatio;\n    let screenY = screenYDevPx / window.devicePixelRatio;\n\n    this._autoScrollPopup.openPopupAtScreen(popupX, popupY);\n    this._ignoreMouseEvents = true;\n    this._startX = screenX;\n    this._startY = screenY;\n    this._autoScrollBrowsingContext = browsingContext;\n    this._acquireAutoScrollWakeLock();\n\n    window.addEventListener(\"mousemove\", this, true);\n    window.addEventListener(\"mousedown\", this, true);\n    window.addEventListener(\"mouseup\", this, true);\n    window.addEventListener(\"DOMMouseScroll\", this, true);\n    window.addEventListener(\"contextmenu\", this, true);\n    window.addEventListener(\"keydown\", this, true);\n    window.addEventListener(\"keypress\", this, true);\n    window.addEventListener(\"keyup\", this, true);\n\n    let usingApz = false;\n\n    if (\n      scrollId != null &&\n      this.mPrefs.getBoolPref(\"apz.autoscroll.enabled\", false)\n    ) {\n      // If APZ is handling the autoscroll, it may decide to cancel\n      // it of its own accord, so register an observer to allow it\n      // to notify us of that.\n      Services.obs.addObserver(this.observer, \"apz:cancel-autoscroll\", true);\n\n      usingApz = browsingContext.startApzAutoscroll(\n        screenXDevPx,\n        screenYDevPx,\n        scrollId,\n        presShellId\n      );\n\n      // Save the IDs for later\n      this._autoScrollScrollId = scrollId;\n      this._autoScrollPresShellId = presShellId;\n    }\n\n    return { autoscrollEnabled: true, usingApz };\n  }\n\n  cancelScroll() {\n    this._autoScrollPopup.hidePopup();\n  }\n\n  handleEvent(aEvent) {\n    if (this._autoScrollBrowsingContext) {\n      switch (aEvent.type) {\n        case \"mousemove\": {\n          var x = aEvent.screenX - this._startX;\n          var y = aEvent.screenY - this._startY;\n\n          if (\n            x > this._AUTOSCROLL_SNAP ||\n            x < -this._AUTOSCROLL_SNAP ||\n            y > this._AUTOSCROLL_SNAP ||\n            y < -this._AUTOSCROLL_SNAP\n          ) {\n            this._ignoreMouseEvents = false;\n          }\n          break;\n        }\n        case \"mouseup\":\n        case \"mousedown\":\n          // The following mouse click/auxclick event on the autoscroller\n          // shouldn't be fired in web content for compatibility with Chrome.\n          aEvent.preventClickEvent();\n        // fallthrough\n        case \"contextmenu\": {\n          if (!this._ignoreMouseEvents) {\n            // Use a timeout to prevent the mousedown from opening the popup again.\n            // Ideally, we could use preventDefault here, but contenteditable\n            // and middlemouse paste don't interact well. See bug 1188536.\n            setTimeout(() => this._autoScrollPopup.hidePopup(), 0);\n          }\n          this._ignoreMouseEvents = false;\n          break;\n        }\n        case \"DOMMouseScroll\": {\n          this._autoScrollPopup.hidePopup();\n          aEvent.preventDefault();\n          break;\n        }\n        case \"popuphidden\": {\n          // TODO: When the autoscroller is closed by clicking outside of it,\n          //       we need to prevent following click event for compatibility\n          //       with Chrome.  However, there is no way to do that for now.\n          this._autoScrollPopup.removeEventListener(\"popuphidden\", this, true);\n          this.stopScroll();\n          break;\n        }\n        case \"keydown\": {\n          if (aEvent.keyCode == aEvent.DOM_VK_ESCAPE) {\n            // the escape key will be processed by\n            // nsXULPopupManager::KeyDown and the panel will be closed.\n            // So, don't consume the key event here.\n            break;\n          }\n          // don't break here. we need to eat keydown events.\n        }\n        // fall through\n        case \"keypress\":\n        case \"keyup\": {\n          // All keyevents should be eaten here during autoscrolling.\n          aEvent.stopPropagation();\n          aEvent.preventDefault();\n          break;\n        }\n      }\n    }\n  }\n\n  closeBrowser() {\n    // The request comes from a XPCOM component, we'd want to redirect\n    // the request to tabbrowser.\n    let tabbrowser = this.getTabBrowser();\n    if (tabbrowser) {\n      let tab = tabbrowser.getTabForBrowser(this);\n      if (tab) {\n        tabbrowser.removeTab(tab);\n        return;\n      }\n    }\n\n    throw new Error(\n      \"Closing a browser which was not attached to a tabbrowser is unsupported.\"\n    );\n  }\n\n  swapBrowsers(aOtherBrowser) {\n    // The request comes from a XPCOM component, we'd want to redirect\n    // the request to tabbrowser so tabbrowser will be setup correctly,\n    // and it will eventually call swapDocShells.\n    let ourTabBrowser = this.getTabBrowser();\n    let otherTabBrowser = aOtherBrowser.getTabBrowser();\n    if (ourTabBrowser && otherTabBrowser) {\n      let ourTab = ourTabBrowser.getTabForBrowser(this);\n      let otherTab = otherTabBrowser.getTabForBrowser(aOtherBrowser);\n      ourTabBrowser.swapBrowsers(ourTab, otherTab);\n      return;\n    }\n\n    // One of us is not connected to a tabbrowser, so just swap.\n    this.swapDocShells(aOtherBrowser);\n  }\n\n  swapDocShells(aOtherBrowser) {\n    if (this.isRemoteBrowser != aOtherBrowser.isRemoteBrowser) {\n      throw new Error(\n        \"Can only swap docshells between browsers in the same process.\"\n      );\n    }\n\n    // Give others a chance to swap state.\n    // IMPORTANT: Since a swapDocShells call does not swap the messageManager\n    //            instances attached to a browser to aOtherBrowser, others\n    //            will need to add the message listeners to the new\n    //            messageManager.\n    //            This is not a bug in swapDocShells or the FrameLoader,\n    //            merely a design decision: If message managers were swapped,\n    //            so that no new listeners were needed, the new\n    //            aOtherBrowser.messageManager would have listeners pointing\n    //            to the JS global of the current browser, which would rather\n    //            easily create leaks while swapping.\n    // IMPORTANT2: When the current browser element is removed from DOM,\n    //             which is quite common after a swapDocShells call, its\n    //             frame loader is destroyed, and that destroys the relevant\n    //             message manager, which will remove the listeners.\n    let event = new CustomEvent(\"SwapDocShells\", { detail: aOtherBrowser });\n    this.dispatchEvent(event);\n    event = new CustomEvent(\"SwapDocShells\", { detail: this });\n    aOtherBrowser.dispatchEvent(event);\n\n    // We need to swap fields that are tied to our docshell or related to\n    // the loaded page\n    // Fields which are built as a result of notifactions (pageshow/hide,\n    // DOMLinkAdded/Removed, onStateChange) should not be swapped here,\n    // because these notifications are dispatched again once the docshells\n    // are swapped.\n    var fieldsToSwap = [\"_webBrowserFind\", \"_rdmFullZoom\"];\n\n    if (this.isRemoteBrowser) {\n      fieldsToSwap.push(\n        ...[\n          \"_remoteWebNavigation\",\n          \"_remoteFinder\",\n          \"_documentURI\",\n          \"_documentContentType\",\n          \"_characterSet\",\n          \"_mayEnableCharacterEncodingMenu\",\n          \"_contentPrincipal\",\n          \"_contentPartitionedPrincipal\",\n          \"_isSyntheticDocument\",\n          \"_originalURI\",\n          \"_userTypedValue\",\n        ]\n      );\n    }\n\n    var ourFieldValues = {};\n    var otherFieldValues = {};\n    for (let field of fieldsToSwap) {\n      ourFieldValues[field] = this[field];\n      otherFieldValues[field] = aOtherBrowser[field];\n    }\n\n    if (window.PopupNotifications) {\n      PopupNotifications._swapBrowserNotifications(aOtherBrowser, this);\n    }\n\n    try {\n      this.swapFrameLoaders(aOtherBrowser);\n    } catch (ex) {\n      // This may not be implemented for browser elements that are not\n      // attached to a BrowserDOMWindow.\n    }\n\n    for (let field of fieldsToSwap) {\n      this[field] = otherFieldValues[field];\n      aOtherBrowser[field] = ourFieldValues[field];\n    }\n\n    if (!this.isRemoteBrowser) {\n      // Null the current nsITypeAheadFind instances so that they're\n      // lazily re-created on access. We need to do this because they\n      // might have attached the wrong docShell.\n      this._fastFind = aOtherBrowser._fastFind = null;\n    } else {\n      // Rewire the remote listeners\n      this._remoteWebNavigation.swapBrowser(this);\n      aOtherBrowser._remoteWebNavigation.swapBrowser(aOtherBrowser);\n\n      if (this._remoteFinder) {\n        this._remoteFinder.swapBrowser(this);\n      }\n      if (aOtherBrowser._remoteFinder) {\n        aOtherBrowser._remoteFinder.swapBrowser(aOtherBrowser);\n      }\n    }\n\n    event = new CustomEvent(\"EndSwapDocShells\", { detail: aOtherBrowser });\n    this.dispatchEvent(event);\n    event = new CustomEvent(\"EndSwapDocShells\", { detail: this });\n    aOtherBrowser.dispatchEvent(event);\n  }\n\n  getInPermitUnload(aCallback) {\n    if (this.isRemoteBrowser) {\n      let { remoteTab } = this.frameLoader;\n      if (!remoteTab) {\n        // If we're crashed, we're definitely not in this state anymore.\n        aCallback(false);\n        return;\n      }\n\n      aCallback(\n        this._inPermitUnload.has(this.browsingContext.currentWindowGlobal)\n      );\n      return;\n    }\n\n    if (!this.docShell || !this.docShell.docViewer) {\n      aCallback(false);\n      return;\n    }\n    aCallback(this.docShell.docViewer.inPermitUnload);\n  }\n\n  async asyncPermitUnload(action) {\n    let wgp = this.browsingContext.currentWindowGlobal;\n    if (this._inPermitUnload.has(wgp)) {\n      throw new Error(\"permitUnload is already running for this tab.\");\n    }\n\n    this._inPermitUnload.add(wgp);\n    try {\n      let permitUnload = await wgp.permitUnload(\n        action,\n        lazyPrefs.unloadTimeoutMs\n      );\n      return { permitUnload };\n    } finally {\n      this._inPermitUnload.delete(wgp);\n    }\n  }\n\n  get hasBeforeUnload() {\n    function hasBeforeUnload(bc) {\n      if (bc.currentWindowContext?.hasBeforeUnload) {\n        return true;\n      }\n      return bc.children.some(hasBeforeUnload);\n    }\n    return hasBeforeUnload(this.browsingContext);\n  }\n\n  get hasActiveCloseWatcher() {\n    function hasActiveCloseWatcher(bc) {\n      if (bc.currentWindowContext?.hasActiveCloseWatcher) {\n        return true;\n      }\n      return bc.children.some(hasActiveCloseWatcher);\n    }\n    return hasActiveCloseWatcher(this.browsingContext);\n  }\n\n  permitUnload(action) {\n    if (this.isRemoteBrowser) {\n      if (!this.hasBeforeUnload) {\n        return { permitUnload: true };\n      }\n\n      // Don't bother asking if this browser is hung:\n      if (\n        lazy.ProcessHangMonitor?.findActiveReport(this) ||\n        lazy.ProcessHangMonitor?.findPausedReport(this)\n      ) {\n        return { permitUnload: true };\n      }\n\n      let result;\n      let success;\n\n      this.asyncPermitUnload(action).then(\n        val => {\n          result = val;\n          success = true;\n        },\n        err => {\n          result = err;\n          success = false;\n        }\n      );\n\n      // The permitUnload() promise will, alas, not call its resolution\n      // callbacks after the browser window the promise lives in has closed,\n      // so we have to check for that case explicitly.\n      Services.tm.spinEventLoopUntilOrQuit(\n        \"browser-custom-element.js:permitUnload\",\n        () => window.closed || success !== undefined\n      );\n      if (success) {\n        return result;\n      }\n      throw result;\n    }\n\n    if (!this.docShell || !this.docShell.docViewer) {\n      return { permitUnload: true };\n    }\n    return {\n      permitUnload: this.docShell.docViewer.permitUnload(),\n    };\n  }\n\n  /**\n   * Gets a screenshot of this browser as an ImageBitmap.\n   *\n   * @param {Number} x\n   *   The x coordinate of the region from the underlying document to capture\n   *   as a screenshot. This is ignored if fullViewport is true.\n   * @param {Number} y\n   *   The y coordinate of the region from the underlying document to capture\n   *   as a screenshot. This is ignored if fullViewport is true.\n   * @param {Number} w\n   *   The width of the region from the underlying document to capture as a\n   *   screenshot. This is ignored if fullViewport is true.\n   * @param {Number} h\n   *   The height of the region from the underlying document to capture as a\n   *   screenshot. This is ignored if fullViewport is true.\n   * @param {Number} scale\n   *   The scale factor for the captured screenshot. See the documentation for\n   *   WindowGlobalParent.drawSnapshot for more detail.\n   * @param {String} backgroundColor\n   *   The default background color for the captured screenshot. See the\n   *   documentation for WindowGlobalParent.drawSnapshot for more detail.\n   * @param {boolean|undefined} fullViewport\n   *   True if the viewport rect should be captured. If this is true, the\n   *   x, y, w and h parameters are ignored. Defaults to false.\n   * @returns {Promise}\n   * @resolves {ImageBitmap}\n   */\n  async drawSnapshot(x, y, w, h, scale, backgroundColor, fullViewport = false) {\n    let rect = fullViewport ? null : new DOMRect(x, y, w, h);\n    try {\n      return this.browsingContext.currentWindowGlobal.drawSnapshot(\n        rect,\n        scale,\n        backgroundColor\n      );\n    } catch (e) {\n      return false;\n    }\n  }\n\n  dropLinks(aLinks, aTriggeringPrincipal) {\n    if (!this.droppedLinkHandler) {\n      return false;\n    }\n    let links = [];\n    for (let i = 0; i < aLinks.length; i += 3) {\n      links.push({\n        url: aLinks[i],\n        name: aLinks[i + 1],\n        type: aLinks[i + 2],\n      });\n    }\n    this.droppedLinkHandler(null, links, aTriggeringPrincipal);\n    return true;\n  }\n\n  getContentBlockingLog() {\n    let windowGlobal = this.browsingContext.currentWindowGlobal;\n    if (!windowGlobal) {\n      return null;\n    }\n    return windowGlobal.contentBlockingLog;\n  }\n\n  getContentBlockingEvents() {\n    let windowGlobal = this.browsingContext.currentWindowGlobal;\n    if (!windowGlobal) {\n      return 0;\n    }\n    return windowGlobal.contentBlockingEvents;\n  }\n\n  // Send an asynchronous message to the remote child via an actor.\n  // Note: use this only for messages through an actor. For old-style\n  // messages, use the message manager.\n  // The value of the scope argument determines which browsing contexts\n  // are sent to:\n  //   'all' - send to actors associated with all descendant child frames.\n  //   'roots' - send only to actors associated with process roots.\n  //   undefined/'' - send only to the top-level actor and not any descendants.\n  sendMessageToActor(messageName, args, actorName, scope) {\n    if (!this.frameLoader) {\n      return;\n    }\n\n    function sendToChildren(browsingContext, childScope) {\n      let windowGlobal = browsingContext.currentWindowGlobal;\n      // If 'roots' is set, only send if windowGlobal.isProcessRoot is true.\n      if (\n        windowGlobal &&\n        (childScope != \"roots\" || windowGlobal.isProcessRoot)\n      ) {\n        windowGlobal.getActor(actorName).sendAsyncMessage(messageName, args);\n      }\n\n      // Iterate as long as scope in assigned. Note that we use the original\n      // passed in scope, not childScope here.\n      if (scope) {\n        for (let context of browsingContext.children) {\n          sendToChildren(context, scope);\n        }\n      }\n    }\n\n    // Pass no second argument to always send to the top-level browsing context.\n    sendToChildren(this.browsingContext);\n  }\n\n  enterModalState() {\n    this.sendMessageToActor(\"EnterModalState\", {}, \"BrowserElement\", \"roots\");\n  }\n\n  leaveModalState() {\n    this.sendMessageToActor(\n      \"LeaveModalState\",\n      { forceLeave: true },\n      \"BrowserElement\",\n      \"roots\"\n    );\n  }\n\n  /**\n   * Can be called for a window with or without modal state.\n   * If the window is not in modal state, this is a no-op.\n   */\n  maybeLeaveModalState() {\n    this.sendMessageToActor(\n      \"LeaveModalState\",\n      { forceLeave: false },\n      \"BrowserElement\",\n      \"roots\"\n    );\n  }\n\n  getDevicePermissionOrigins(key) {\n    if (typeof key !== \"string\" || key.length === 0) {\n      throw new Error(\"Key must be non empty string.\");\n    }\n    if (!this._devicePermissionOrigins) {\n      this._devicePermissionOrigins = new Map();\n    }\n    let origins = this._devicePermissionOrigins.get(key);\n    if (!origins) {\n      origins = new Set();\n      this._devicePermissionOrigins.set(key, origins);\n    }\n    return origins;\n  }\n\n  // This method is replaced by frontend code in order to delay performing the\n  // process switch until some async operatin is completed.\n  //\n  // This is used by tabbrowser to flush SessionStore before a process switch.\n  async prepareToChangeRemoteness() {\n    /* no-op unless replaced */\n  }\n\n  // This method is replaced by frontend code in order to handle restoring\n  // remote session history\n  //\n  // Called immediately after changing remoteness.  If this method returns\n  // `true`, Gecko will assume frontend handled resuming the load, and will\n  // not attempt to resume the load itself.\n  afterChangeRemoteness() {\n    /* no-op unless replaced */\n    return false;\n  }\n\n  // Called by Gecko before the remoteness change happens, allowing for\n  // listeners, etc. to be stashed before the process switch.\n  beforeChangeRemoteness() {\n    // Fire the `WillChangeBrowserRemoteness` event, which may be hooked by\n    // frontend code for custom behaviour.\n    let event = document.createEvent(\"Events\");\n    event.initEvent(\"WillChangeBrowserRemoteness\", true, false);\n    this.dispatchEvent(event);\n\n    // Destroy ourselves to unregister from observer notifications\n    // FIXME: Can we get away with something less destructive here?\n    this.destroy();\n  }\n\n  finishChangeRemoteness(redirectLoadSwitchId) {\n    // Re-construct ourselves after the destroy in `beforeChangeRemoteness`.\n    this.construct();\n\n    // Fire the `DidChangeBrowserRemoteness` event, which may be hooked by\n    // frontend code for custom behaviour.\n    let event = document.createEvent(\"Events\");\n    event.initEvent(\"DidChangeBrowserRemoteness\", true, false);\n    this.dispatchEvent(event);\n\n    // Call into frontend code which may want to handle the load (e.g. to\n    // while restoring session state).\n    return this.afterChangeRemoteness(redirectLoadSwitchId);\n  }\n}\n\nMozXULElement.implementCustomInterface(MozBrowser, [Ci.nsIBrowser]);\ncustomElements.define(\"browser\", MozBrowser);\n"],"names":[],"sourceRoot":""}